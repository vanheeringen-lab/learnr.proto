---
title: "Week 2: Exploratory & Overlap analysis"
tutorial:      # where learnr stores the progress
  id: "FG2"    # folder name
  version: 0.1 # subfolder name
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: true
    allow_skip: true
    css: css/custom.css
runtime: shiny_prerendered
description: >
  Multi line text can be put here
  for your convenience.
---


```{r setup, include=FALSE}
library(learnr)     # 0.10.1.9006 (github)
library(gradethis)  # 0.1.0.9004  (github)
library(testthat)   # 3.0.0 
library(tidyverse)  # 1.3.0
library(learnr.proto)

library(IRanges)
library(GenomicRanges)
library(plyranges)
library(rtracklayer)
library(VennDiagram)
library(GenomicFeatures)
# library(TxDb.Hsapiens.UCSC.hg19.knownGene)
# library(TxDb.Hsapiens.UCSC.hg38.knownGene)
# library(ChIPpeakAnno)
# library(UpSetR)
# library(genomation)

# configuration
knitr::opts_chunk$set(echo = FALSE, message = F)
gradethis::gradethis_setup()

# data accessible to all exercises
rdata = system.file("extdata", "week2.Rdata", package = "learnr.proto")
load(rdata)
monocytes_all <- unlist(monocytes_list)
monocytes_all$chip <- names(monocytes_all)

rdata = system.file("extdata", "week2", "prepared_rds", "txdb_annotation_chr19_genes_tx_pr_tss_granges.RData", package = "learnr.proto")
load(rdata)
# identify TSS (in this case 1 per gene even though we know that genes have multiple TSSs)
tss <- resize(genes, width = 1, fix = "start")

# consider 1kb upstream and 200bp downstream the TSS as promoter
promoters <- resize(tss, width = 1000, fix = "end")
promoters <- resize(promoters, width = 1200, fix = "start")

```

```{r timeout1, context="server"}
isolate({
  # obtain the session id
  # source 1: https://shiny.rstudio.com/reference/shiny/latest/session.html
  # source 2: https://stackoverflow.com/questions/18900955/get-environment-identifier-in-r
  session_id <- sub('<environment: (.*)>', '\\1', capture.output(session$userData))
  
  # # send the session ID to the log (indicates the tutorial is loaded)
  # write(paste0("Session ID: ", session_id), stderr())
  
  # send the session ID to the javascript chunk
  session$sendCustomMessage("session_id", session_id)
})

# stop the tutorial when "input[[session_id]]" is updated
observeEvent(input[[session_id]], ignoreNULL=T, {
  write(paste0("\nTutorial terminated due to inactivity.\nRestart to continue where you left off!\n"), stderr())
  stopApp()
})
```

```{js timeout2}
// This chunk stops the tutorial if it has been idle for too long

// Situation: We need to stop inactive tutorials to prevent the server from grinding to a halt.
// Problem: refreshing the tutorial and closing the browser send the same signal to shiny.
// since we cannot distinguish the two, this signal cannot be used to stop the tutorial.
// solution: Use a timeout system. 
// Method: this chunk will update shiny variable "input[[session_id]]" 
//   when the session has been running idle for longer than "timeoutSec" seconds.
// This signal is then be used by Shiny (server-side) to stop the session.

// source1: https://community.rstudio.com/t/keeping-track-of-idle-time-during-app-usage/1735
// source2: https://bookdown.org/yihui/rmarkdown/language-engines.html#javascript-and-css
$(function() {
  var timeoutSec = 5*60;
  var idleTimer;

  // receive this session's ID
  Shiny.addCustomMessageHandler("session_id", function(s_id) {
    session_id = s_id;  // assigns the variable globally
  });

  // assign session ID as reactive variable "input[[session_id]]" 
  function onTimeout() {
    alert("Tutorial stopped due to inactivity.\nRestart to continue where you left off!")
    Shiny.setInputValue(session_id, "TRUE");
  }

  function startIdleTimer() {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(onTimeout, timeoutSec * 1000);
  }
  
  $(document).on('shiny:message shiny:inputchanged', startIdleTimer);

})();
```


## 2.1 Introduction   
<br>
In week 1 we discussed the major steps involved in obtaining genomics data, from experiment to raw data to normalized signal and peaks. You examined histone PTM ChIP-, DNaseI-, and RNA-seq data of monocytes in the UCSC genome browser and searched for regions with increased signal, *peaks*. You looked at the position of these peaks in the chromosome and with respect to genes as well as the co-occurrence of different marks.   
<br>
These observations showed examples of marks associated with a particular functional elements (e.g. active enhancer, active promoter, silenced domains). Manual annotation of each peak region would be an overkill and dangerously subjective. 
<br>
**This week and next week you will perform computational analyses to annotate peaks and answer common questions including:** "*How many peaks do I have?*", "*Is this mark statistically enriched in a particular genomic element?*", "*Which and how often do marks co-occur?*","*The expression of which gene could be affected by this mark?*",  and "*What is the signal of the mark around a particular element of interest like the TSS?*"   
<br>

### 2.1.1 Learning Objectives  

> At the end of week 2 you are able to:  
> 
1. Import ChIP-seq peaks into a GRanges object in r.  
2. Perform exploratory data analysis on GRanges objects with ChIP-seq peaks.   
3. Detect and count overlap between two GRanges objects.    
4. Visualize the number of overlaps in a vennDiagram.  
5. Visualize the number of overlaps with bar- and pieplots.   
6. Statistically test for enrichment of histone marks in a particular genomic region. 
7. Optionally, quantify and plot the overlap among histone marks (a  tiny bit like chromHMM but much less fancy, ggplot + geom_bar with index at the bottom for the different combinations or plot the tabular output as heatmap with nubmer display).  
8. Identify the nearest TSS to a histone ChIP-seq peak.  
9. Identify the genes that are associated with these TSSs.  
- These refer to global learning objectives #4-#7.  

### Exercises
In this tutorial you will have multiple-choice and checkbox questions like in **fg1** but also complete-the-code exercises. The latter can be evaluated on the computed outcome (e.g a computed p-value), in other cases, the code itself is checked. 
<br>
For short lines of code, you have to decide which function or object to use and how to write this in code. For some longer lines of codes, we left blanks as "___" that indicate where in the code you should add the function or object name.  
<br>

- Hit `Start Over` to remove any adjustments you made and start again.   
- Hit `Hint` (when provided) for clues.  
- Hit `Run Code` to preview your code and the output.  
- Hit `Submit Answer` (if present) to submit the code. As 'submitting' not always shows the code output, it is advised to use `Run Code` first.  

<br>
```{r exemplemc}
quiz(caption = "Example questions:",
     question("What number is the letter A in the English alphabet?",
        answer("8"),
        answer("14"),
        answer("1", correct = TRUE),
        answer("23")
     ),
     question("Where are you right now? (select ALL that apply)",
          answer("Planet Earth", correct = TRUE),
          answer("Pluto"),
          answer("At a computing device", correct = TRUE),
          answer("In the Milky Way", correct = TRUE),
          incorrect = "Incorrect. You're on Earth, in the Milky Way, at a computer.")
)
```

**Example coding exercise:**  

> * Print the head of file `monocytes_h3k4me3`.   

```{r examplecode, exercise = T}
# print the head of `monocytes_h3k4me3`

```

<div id="examplecode-hint">
**Hint:** You may want to use the `head(...)` function.  
</div>

```{r examplecode-solution}
head(monocytes_h3k4me3)
```

```{r examplecode-check-code}
grade_result(
  pass_if(
    ~identical(.result, head(monocytes_h3k4me3))
    )
 )
```

<br>  

***  
<br> 

## 2.2 ChIP-seq peaks in R  {data-progressive=TRUE}  
### 2.2.1 Data formats      
In genomics you often work with **interval** data. Think of peaks, genes, exons, ... any genomic region reported with the **genomic coordinates: chr, start, and end**. As we discussed in week 1, these often come in a tabular format with the basic information about the location and some other information.  
<br>
Common file formats include BED format for peak files, GFF for gene annotations, and BigWig for read depth. In practice, peak files come in two flavours, both cohering to the BED format but with small differences in columns 6-7. These are called **narrowPeak** and **broadPeak** files. This is because different data types have different peak shapes and peak-calling takes that into account. If you have narrowPeak files, this means that during peak calling, settings were used that fit ChIP-seq datasets with sharp, narrow enrichment signals. For broadPeak files, peak calling settings were used to detect broad domains of (overall lower) enrichment. We will come back to this difference shortly.      
 

>#### **Background info**: File formats   
<details><summary>What do BED, GFF, BigWig files hold and look like?</summary>   
**Browser Extensible Data - BED format**:  
>
- Used for peaks, motif locations or other custom intervals.  
- Has 3 required columns: chromosome, start and end position.  
- 6 or 7 optional columns, in case of peaks:  
  4th: peak name  
  5th: peak score (-10log(q-value) * 10, rounded down to integer value))  
  6th: strand to denote orientation (if applicable, otherwise "\*" or "\." if unstranded)  
  7th: signalValue  
  8th: p-value to denote statistical significance, given as -log10(p-value)  
  9th: q-value statistical significance using false discoveray rate, given as -log10(q-value)  
  10th (only for sharp peaks not broad domains): location of peak summit relative to the "start" coordinate.  
>
> Example:  
![](images/wk1_3_file_format_bed.png){width=80%}  
> Further reading on the file formats on the UCSC Genome Browser FAQ page: [BED](http://genome.ucsc.edu/FAQ/FAQformat.html#format1), and the [narrowPeak BED](http://genome.ucsc.edu/FAQ/FAQformat.html#format12) and [broadPeak BED](http://genome.ucsc.edu/FAQ/FAQformat.html#format13).  
> <br>
> **General Feature Format - GFF format**:   
>  
-	Common file format for storing gene annotations not only including genes but also transcripts/splice variants, cDNA sequences, exons, rRNA, ncRNA, etc.  
-	Begins with meta-data in headerlines, starting with #  
-	Records reported in 9 fixed columns  
-	Column 9 can contains various attirbutes (eg gene symbol, the transcript to which the exon belongs).  
- Downloaded for example from [Ensembl](https://www.ensembl.org/Homo_sapiens/Info/Index).  
>
> Example:   
![](images/wk1_3_file_format_gff.png){width=80%}      
> Further reading on the gff file formats: [UCSC Genome Browser](http://genome.ucsc.edu/FAQ/FAQformat.html#format3), or [ENSEMBL](https://m.ensembl.org/info/website/upload/gff3.html).  
> <br>
> **Wiggle or bigWig files**:  
- Read depth is often stored in BigWig files.  
- BigWig files are binary versions of (mucht larger) wiggle files.  
- BigWig files are faster to upload and use but can't be viewed by us.  
- Wiggle files can be viewed but are slow to upload.   
- Wiggle files report a genomic region with the data value for that region. For this practical it is not neccessary to know the details of how these files are generatd. But if you are curious, read the UCSC Genome browser documentation on [wiggle](https://genome.ucsc.edu/goldenPath/help/wiggle.html) and [bigWig](https://genome.ucsc.edu/goldenPath/help/bigWig.html) file formats.  
</details>

### 2.2.2 Peaks as data.frame     
<br>
Peak data can be imported into a data.frame with:  
```{r exampleimport, eval =F, echo =T}
object_name <- read.table("location/of/peak_file.bed")
```
<br>
The data.frame data structure is, however, not the most efficient way to work with interval data. E.g. a simple manipulation such as shifting all reported intervals 2 bp to the right, requires you to manipulate the "start" and "end" columns at the same time.  
<br>
Interval data such as genomic peaks can be more efficiently handled with the IRanges package which works with a data structure especially developed for **ranges of integers**: IRanges objects.  

### 2.2.3 Introducing IRanges and GRanges    
To construct an IRanges object you need to define at least two of the following three values:  

1. a starting coordinate  
2. a finishing coordinate  
3. the width of the interval.  

<br>
The GRanges objects of the GenomicRanges package are very similar but require a additional **sequence name** (in other words a chromosome) for every interval and an optional **strand** column.  
<br> 
Here we create GRanges object called `gr` with 3 interals on chr1:  
```{r create gr, echo = T, eval = T}
# create `gr`
gr_chr1 <-  GRanges(seqnames = c("chr1"), # argument is recycled  
              ranges = IRanges(start=c(5,10,25), width = c(13,17,6)),
              strand = c("-","+", "+"),
              color = c("black", "red", "green"))
# add names to `gr_chr1`
names(gr_chr1) <- paste("interval", LETTERS[1:3], sep = "_")
# print the object:
gr_chr1
```
<br>
When we visualize these intervals we see three 'blocks' along the horizontal axis:
```{r plot gr, echo = F}
plotRanges(gr_chr1, col = gr_chr1$color)
rm(gr_chr1)
```

### 2.2.4 Handy functions for GRanges    
There are several functions to retrieve and set the values in GRanges objects. Here is an image of a GRanges object called `gr` with the respective functions. You will use these functions soon.  

![](images/wk2_2_GRanges_fields_my_gr.png){width=100%}   
<br>
A list of the above functions (and more) for GRanges can also be called with `methods(class = "...")`. This also command works for other objects as well. You just need to figure out the class of the object in question using `class([object_name])`.  
<br>
You can print a summary of the GRanges object with `show(object_name)` and `print(object_name)` (this works for many  other R objects as well).  
<br>

### 2.2.5 Slots in GRanges objects     
Notice that `gr` holds 3 slots:  

1. the genomic coordinates in a **GRanges** slot  
2. 2 columns as **metadata**  (metadata is data about the data)    
3. a genome in the **seqinfo** slot  

The main differences between the metadata and the genomic coordinates are:  

Genomic coordinates |  Metadata columns   
:--|:---  
Printed on the left-hand side of the \|-sign | Printed on the right-hand side of the \|-sign     
Extract using `granges(object_name)` |  Extract as DataFrame with `mcols(object_name)` or `object_name$column_name` for a specific column   
Restricted to variables `seqnames`, `ranges` and `strand` | Almost anything can be stored in the metadata

<br>
Information about the genome is stored in the **seqinfo** part of the object. In the example you see that the peaks are located in human genome 38 which holds 455 sequences in total of which 1 circular (mitochondrial genome). (Sequences that can not be confidently placed on a specific chromosome is stored in chrUn, chr*N*_random and chr*N*_region [explanation on UCSC GB website](http://genome.ucsc.edu/FAQ/FAQdownloads#download10).)   


### 2.2.6 Importing peak files as GRanges     
To parse peak files directly into GRanges you use the `import()` function from the rtracklayer package, for example:    
```{r exampleimport_rtracklayer, eval = F, echo = T}
# load the required library, is usually done once at the start of your analysis.  
library(rtracklayer)

# import monocyte H3K4me3 peak locations
monocytes_h3k4me3 <- import("C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed", format = "narrowPeak")

# (you could also use rtracklayer::import("C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed", format = "narrowPeak") and skip loading the library)
```
<br>
As mentioned above (2.2.1), different data types have different peak shapes resulting in "narrowPeak" and "broadPeak" files. H3K4me3 ChIP-seq generally shows sharp(er) enrichment that can reach high enrichment values. For `import()` to function properly, we defined this format in the `format = ` parameter.  
<br>
H3K4me1 ChIP-seq cover broad(er) domains and peak calling took that into account, resulting in a "broadPeak" peak file. 
```{r qimport}
question("Which function imports the H3K4me1 dataset into a GRanges object?",
         answer("import(\"C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.broad.20150527.chr19.bed\", format = \"narrowPeak\")", message = "check the file format."),
         answer("import(\"C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.broad.20150527.chr19.bed\", format = \"BED\")", message = "BED is not the right format."),
         answer("import(\"C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.broad.20150527.chr19.bed\", format = \"broadPeak\")", correct =T),
         answer("read.table(\"C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.broad.20150527.chr19.bed\", format = \"broadPeak\")", message = "read.table parses the data into a data.frame while we asked for a GRanges object."),
         allow_retry = TRUE,
         random_answer_order = TRUE
         )
```
<br>
Let's take a quick look at `monocytes_h3k4me3`.     

### Exercise 1:  

> **Exercise 1a**: Print the head of `monocytes_h3k4me3`.  

```{r q1_head_h3k4me3, exercise = TRUE}
# print the head of monocytes_h3k4me3  
# the object "monocytes_h3k4me3" has already been imported for you


```

<div id="q1_head_h3k4me3-hint">
**Hint:** Use the `head(...)` function.  
</div>

```{r q1_head_h3k4me3-solution}
head(monocytes_h3k4me3)
```

```{r q1_head_h3k4me3-check-code}
grade_result(
 pass_if(~identical(.result, head(monocytes_h3k4me3)))
 )
```

```{r quiz_grangesobject}
quiz(caption = "", 
    question("How many metadata columns does the 'monocytes_h3k4me3' object have?",
             answer("2"),
             answer("3"),
             answer("6", correct = T, message = "The original .BED files lacked column headers. The `rtracklayer::import()` function appendended variable names and converted the data to the data type (eg numeric, integer, character etc.) according to the file format we defined."),   
             answer("9"), 
             allow_retry = TRUE),
    question("How many different chromosomes are reported in this file? *Hint*: look in seqinfo part of the object.",
             answer("1", correct = T, message = "We have restricted all peak files to chromosome 19 to limit their file size. That is why 'seqinfo' holds only one sequence"),
             answer("24"),
             answer("455"),
             allow_retry = TRUE)
)
```

Briefly summarizing, you have the following information in your object `monocytes_h3k4me3`:  

Column | Section in GRanges object | Variable | Description   
-- | --- | --- | ------  
1. | GRanges | seqnames | chromosome name of peak location.        
2. | GRanges | ranges | start and enc position of peak.         
3. | GRanges | strand | if applicable, orientation of the peak, otherwise \*\.        
4. | Metadata | name | peak name, given by the peak caller.     
5. | Metadata | score | -10log(qvalue) * 10, rounded down to integer value.  
6. | Metadata | signalValue | enrichment signal at the peak summit.  
7. | Metadata | pValue | -log10(p-value), (*e.g.if p-value = 1e-10, this value is 10*), roughly put, the significance of the enrichment.   
8. | Metadata | qValue | -log10(qvalue), the false discovery rate determined by swapping test and control.  
9. | Metadata | peak  | location of peak summit relative to the peak start.  

## 2.3 Exploratory data analysis   
### 2.3.1 Peak counts
A common first step in genomics data analysis is to make look at some basic characteristics of our data by making exploratory summaries and plots.  
<br>

### Exercise 2:    

> **Exercise 2a**: Determine the number of H3K4me3 and H3K4me1 peaks in monocytes. 
> 
> * The peak data are stored in the R objects `monocytes_h3k4me3` and `monocytes_h3k4me1`.    

```{r q2a_exploreh3k4me3, exercise = T}
# How many peaks are stored in monocytes_h3k4me3?
monocytes_h3k4me3

```

<div id="q2a_exploreh3k4me3-hint">
**Hint:** You may want to use the `length()` function.  
</div>

```{r q2a_exploreh3k4me3-solution, eval = F}
length(monocytes_h3k4me3)
```

```{r q2a_exploreh3k4me3-check, eval = F}
grade_result(
 pass_if(~identical(.result, length(monocytes_h3k4me3)))
 )
```

```{r q2a_exploreh3k4me1, exercise = T}
# And how many H3K4me1 peaks do you have?


```

```{r q2a_exploreh3k4me1-solution, eval = F}
length(monocytes_h3k4me1)
```

```{r q2a_exploreh3k4me1-check, eval = F}
grade_result(
 pass_if(~identical(.result, length(monocytes_h3k4me1)))
 )
```

> **Exercise 2b**: And what is the distribution of peak sizes for these marks? 

```{r q2b_widthh3k4me3, exercise = T}
# What is the distribution of H3K4me3 peak sizes?   
summary(___(monocytes_h3k4me3))
```

<div id="q2b_widthh3k4me3-hint">
**Hint:** You can retrieve peak widths with the `width()` function.  
</div>

```{r q2b_widthh3k4me3-solution}
summary(width(monocytes_h3k4me3))
```

```{r q2b_widthh3k4me3-code-check}
grade_code(
  pass_if(~identical(.result, summary(width(monocytes_h3k4me3))))
)
```

```{r q2b_widthh3k4me1, exercise = T}
# And what is the distribution of H3K4me1 peak sizes?   
monocytes_h3k4me1
```

```{r q2b_widthh3k4me1-solution}
summary(width(monocytes_h3k4me1))
```

```{r q2b_widthh3k4me1-code-check}
grade_code(
  pass_if(~identical(.result, summary(width(monocytes_h3k4me1))))
)
```

```{r quiz_peakgranges}
quiz(caption = "", 
    question("What are the median peak sizes for H3K4me3 and H3K4me1 ChIP-seq peaks in the current dataset? (in monocytes, restricted to chromosome19)",
             answer("median H3K4me3 peak = 879.5 bp", correct = T),
             answer("median H3K4me3 peak = 1662 bp"),
             answer("median H3K4me3 peak = 1198.6 bp"),   
             answer("median H3K4me3 peak = 2642 bp"),
             answer("median H3K4me1 peak = 879.5 bp"),
             answer("median H3K4me1 peak = 1662 bp", correct = T),
             answer("median H3K4me1 peak = 1198.6 bp"),   
             answer("median H3K4me1 peak = 2642 bp"), 
             allow_retry = TRUE),
    question("And what are the widths of the *largest* peaks in the current H3K4me3 and H3K27me1 ChIP-seq datasets of monocytes?",
             answer("largest H3K4me3 peak = 8237 bp", message = "8237 bp is the width of the largest H3K27ac peak on chr19" ),
             answer("largest H3K4me3 peak = 12705 bp", correct = T),
             answer("largest H3K4me3 peak = 73112 bp", message = "73112 bp is the width of the largest H3K36me3 peak on chr19" ),   
             answer("largest H3K4me1 peak = 32063 bp", correct = T ),
             answer("largest H3K4me1 peak = 86201 bp", message = "86201 bp is the width of the largest H3K27me3 peak on chr19"),
             answer("largest H3K4me1 peak = 136766 bp", message = "136766 bp is the width of the largest H3K9me3 peak on chr19"),
             allow_retry = TRUE))
```
<br>
Notice the larger median and maximum peak size for H3K4me1 peaks compared to H3K4me3 peaks.  

### 2.3.2 Plotting summaries with ggplot2  
You will use the ggplot2 package to plot the number of peaks for each dataset, to compare the average peak sizes and to plot the total number or fraction of bp's covered by these peaks on chromosome 19.  
<br>

> #### A very brief refresher on ggplot2-ting:   
> With **ggplot2** you generally begin with the `ggplot(data = ..)` function and you add so-called layers with `geom..()` functions. Example geom functions include `geom_point()` for a scatter plot, `geom_histogram()` for a histogram, `geom_density()` for a smoothened version of the histogram, and `geom_bar()` or `geo_col()` for a barplot.  
> <br>
> The **geom functions** take a `mapping = aes(x = ..., y = ..., ...)` argument that defines how variables in the dataset are mapped to visual properties (aes for "aesthetic mapping"). Depending on the geom function, you can map variables to the x- and y-axis, to the shape of symbols, the line type of line graphs, to the fill color of symbols and more.  
> <br>
**Scales** can be customized with `scale_[]_[]` functions. These can be used to for example, change a color palette, set limits to the values included in the mapping, or log transform an axis.  
<br>
A template code for a ggplot2 plot:  
`ggplot(data = <DATA>)+`  
  `geom_<FUNCTION>(mapping = aes(<MAPPING>))+`   
  `<SCALE_FUNCTION>`  
<br>
> **References**:  
> *[R for Datascience, chapter 3 Data visualization](https://r4ds.had.co.nz/data-visualisation.html)*  
> *[ggplot2 cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)*  
 

### Exercise 3:  

> Make a barplot showing the number of peaks per ChIP experiment.   
>  
> * All chip peaks are concatenated in the GRanges object `monocytes_all`.   
**Exercise 3a**: Print a summary of this object using `show()` and identify the variable (column in metadata) that you can use for counting the number of peaks per chip (this will be the statistic used in the barplot).   
* Use the "Run Code" button to ensure that the output is printed.  

```{r monocytesall, exercise = T, exercise.eval = T}
# print summary of object 'monocytes_all'


```

<div id="monocytesall-hint">
**Hint:** Use the `show()` function   
</div>

```{r monocytesall-solution}
show(monocytes_all)
```

```{r monocytesall-code-check}
grade_code(
  pass_if(~identical(.result, show(monocytes_all))))
```

```{r barplotvariable}
question("Which variable will you use for counting the number of peaks per ChIP-seq dataset?",
         answer("score"),
         answer("seqnames"),
         answer("peak"), 
         answer("chip", correct =T),
         allow_retry = T)
```

As GRanges objects are not compatible with ggplot2, you have to extract the metadata and write into a a data.frame  

> **Exercise 3b**: Complete the code below to extract the metadata from the object `monocytes_all`.  
> 
> * The function `as.data.frame()` is used to convert the resulting 'DFrame' object into a data.frame.

```{r q_extractmetadata, message=TRUE, exercise=T, exercise.eval=F, warning=F}
# extract metadata 
monocytes_metadata <- __(__)

# convert to a data.frame
monocytes_metadata <- as.data.frame(monocytes_metadata)
```

```{r q_extractmetadata-hint-1}
monocytes_metadata <- mcols(monocytes_all)
```

```{r q_extractmetadata-solution}
# extract metadata 
monocytes_metadata <- mcols(monocytes_all)

# convert to a data.frame
monocytes_metadata <- as.data.frame(monocytes_metadata)
```

```{r q_extractmetadata-code-check}
grade_code()
```

> **Exercise 3c**: Complete the code below to plot the number of peaks per ChIP in a bar chart using ggplot2 plotting.  

```{r prepare-barplotpeakcount} 
monocytes_metadata <- as.data.frame(mcols(monocytes_all))
```

```{r barplotpeakcount, exercise = T, fig.width=4, exercise.eval =F}
# plot the number of peaks per chip
__(data = __)+
  __(mapping=aes(y=__) )+
  theme_calc()+
  scale_fill_colorblind()+
  theme(legend.position = "none")+
  ggtitle("Number of peaks per ChIP, monocytes, chr19")
```

```{r barplotpeakcount-hint-1}
ggplot(data = monocytes_metadata)
```

```{r barplotpeakcount-hint-2}
geom_bar()
```

```{r barplotpeakcount-hint-3}
ggplot(data = monocytes_metadata)+
  geom_bar(mapping=aes(y=chip))
```

```{r barplotpeakcount-solution}
# plot the number of peaks per chip
ggplot(data = monocytes_metadata)+
  geom_bar(mapping=aes(y=chip))+
  theme_bw()+
  theme(legend.position = "none")+
  ggtitle("Number of peaks per ChIP, monocytes, chr19")
```

```{r q_barplotpeakcount-code-check}
grade_code()
```


*For which marks do you observe the most peaks? And for which the fewest number of peaks? Are these marks associated with gene activation or gene silencing? Did they, in the genome browser, show a sharp peaks or broad domains of enrichment?*  
<br>
The range of peak counts can tell you whether your experiment and peak calling performed as expected. If they show extremely high or low values, it is likely something is off (something you should have already noted in the Genome Browser). It can also function as an extra control step to check that all peaks are indeed imported in R (and no strange things happened to your files along the way).   
<br>
In this case, the number of peaks is correct and you can continue with the analysis. 
<br>

### Exercise 4:   

> Visualize the differences in peak width by making a boxplot showing the peak sizes per chip.    
>  
> **Exercise 4a**: Finish the code below to add the 'peak_size' variable, holding the peak widths, to `monocytes_metadata`.  

```{r prepare-addpeaksize, echo = F}
monocytes_metadata <- as.data.frame(mcols(monocytes_all))
```

```{r addpeaksize, exercise = T}
# add column 'peak_size' to monocytes_metadata with the width of the peaks from monocytes_all 


```

<div id="addpeaksize-hint">
**Hint:** Use `monocytes_metadata$peak_size <- width(monocytes_all)`     
</div>

```{r addpeaksize-solution}
monocytes_metadata$peak_size <- width(monocytes_all)
```

```{r addpeaksize-code-check}
grade_code()
```

> **Exercise 4b**: Now plot the peak size distribution as a boxplot.   

```{r prepare-plotpeaksize}
monocytes_metadata <- as.data.frame(mcols(monocytes_all))
monocytes_metadata$peak_size <- width(monocytes_all)
```

```{r plotpeaksize, exercise = T, exercise.eval =F}
# plot the peak_size per chip as boxplot
__(data = __)+
  __(mapping = __(x = __, y = __), fill = "gray", col = "black", bins = 100)+
  theme_bw()

```

<div id="plotpeaksize-hint">
**Hint:** Use `ggplot(data = monocytes_metadata)+`     
</div>

<div id="plotpeaksize-hint">
**Hint:** and `geom_boxplot(mapping = aes(x = chip, y = ...))`     
</div>

<div id="plotpeaksize-hint">
**Hint:** and y as `geom_boxplot(mapping = aes(x = chip, y = peak_size))`   
</div>

```{r plotpeaksize-solution}
ggplot(data = monocytes_metadata)+
  geom_boxplot(mapping = aes(x = chip, y = peak_size), fill = "gray", col = "black")+
  theme_bw()
```

```{r plotpeaksize-code-check}
grade_code()
```


> **Exercise 4c**: This doesn't look very informative, let's log10-transform the y-axis:  

```{r prepare-plotpeaksizelog}
monocytes_metadata <- as.data.frame(mcols(monocytes_all))
monocytes_metadata$peak_size <- width(monocytes_all)
```

```{r plotpeaksizelog, exercise = T, exercise.eval =F}
# plot the peak_size per chip as boxplot, log10-transform the y-axis
__(data = __)+
  __(mapping = __(x = __, y = __), fill = "gray", col = "black")+
  theme_bw()+
  scale_y_continuous(trans = "__")
```

<div id="plotpeaksizelog-hint">
**Hint:** Specify "log10" for the `trans = ` parameter
</div>

```{r plotpeaksizelog-solution}
ggplot(data = monocytes_metadata)+
  geom_boxplot(mapping = aes(x = chip, y = peak_size), fill = "gray", col = "black")+
  theme_bw()+
  scale_y_continuous(trans = "log10")
```

```{r plotpeaksizelog-code-check}
grade_code()
```

As mentioned in section 2.2.1 and 2.2.6, different data types have different peak shapes. H3K4me3 and H3K4me1 ChIP-seq peaks are resp. **narrow**, and the **broad** peaks. 

```{r q_broad_vs_narrow}
quiz(caption = "Use the boxplot above.", 
     question("Which ChIP-seq dataset has/have broad peak shapes?",
         answer("H3K27ac"),
         answer("3K36me3", correct = T),
         answer("H3K27me3", correct = T),
         answer("H3K9me3", correct = T),
         allow_retry = TRUE),
     question("which have narrow peak shapes?",
         answer("H3K27ac", correct = T),
         answer("3K36me3"),
         answer("H3K27me3"),
         answer("H3K9me3"),
         allow_retry = TRUE,
         message = "You could have gotten this information from the [BLUEPRINT ChIP-Seq Analysis Pipeline description](http://dcc.blueprint-epigenome.eu/#/md/chip_seq_grch38) (remember: FAIR principles!). Under the section **Peak Calling** you can read that peak calling was performed with MACS2 and that the -broad flag was added depending on the mark in question." )
)
```
<br>

><details><summary>In summary, marks with narrow and with broad peaks:</summary>  
>  
> narrowPeak file | broadPeak file  
> :-- |:--  
H3K27ac | H3K27me3   
H3K4me3 | H3K36me3  
H3K9/14ac | H3K9me3  
H2A.Zac | H3K4me1  
</details>  

### 2.3.3 Plotting summarized values using dplyr & ggplot  

> In this section you will visualize the fraction that each ChIP-seq peak set covers in total on chromosome 19.  

To generate this plot, you have to calculate the total number of bps covered by each peak dataset. This can be achieved by summing all the width values.  
<br>
GRanges objects follow the **tidy data principle**: each row of a Ranges object corresponds to an interval, and each column will represent a variable about that interval, and generally each object will represent a single unit of an observation (like gene annotations). You can use **dplyr**-like functions from the `plyranges` package to manipulate these objects and use the **pipe** operator `%>%` to combine functions in a workflow.  

>#### **Refresher**: dplyr     
<details><summary>Common dplyr-functions and examples of their plyranges-relatives on GRanges objects</summary>   
>
Function | Purpose | Example on GRanges   
:--|:----|:----     
`select()` | subset variables (=columns) |  `select(my_gr, GC)`
`group_by()` | group data into rows with the same value for the specified variable. |  `my_gr %>% group_by(strand)`.  
`filter()` | subset observations (= rows) | `filter(my_gr, GC < 0.4)` or `my_gr %>% group_by(strand) %>%  filter(GC == max(GC))`.     
`summarize()` | Summarise variables, often per group | `group_by(my_gr, strand) %>% summarize(n = n(), gc = max(GC))`   
</details>  

### Exercise 5a:  

> To plot the fraction of bps covered by each chip-seq peak dataset first calculate this fraction.  

> **Exercise 5a**: Finish the code below using `group_by()` and `summarize()` to calculate  
> 
> a. the total number of bps covered by each peak dataset and   
> b. as a fraction of total bps in chromosome 19 (=59128983 bp)   


```{r prepare-summarizewidth}
monocytes_metadata <- as.data.frame(mcols(monocytes_all))
monocytes_metadata$peak_size <- width(monocytes_all)
```

```{r summarizewidth, exercise = T, message = F, exercise.eval = F}
# calculate the total number of bps covered by each chipseq dataset
# and as a fraction of total bps in chromosome 19
monocytes_metadata %>% 
  ___ %>%
  summarize(total_bps = ___ ,
            fraction_chr19 = ___ /59128983)
```

<div id="plotpeaksize-hint">
**Hint:** Use `monocytes_metadata %>% group_by(chip)`     
</div>

<div id="plotpeaksize-hint">
**Hint:** piped as `monocytes_metadata %>% group_by(chip) %>% summarize(total_bps = sum(peak_size))`     
</div>

<div id="plotpeaksize-hint">
**Hint:** and and the second summary variable defined as `monocytes_metadata %>% group_by(chip) %>% summarize(total_bps = sum(peak_size), fraction_chr19 = total_bps /59128983)`   
</div>

```{r summarizewidth-solution, eval = F}
monocytes_metadata %>% group_by(chip) %>% 
  summarize(total_bps = sum(peak_size),
            fraction_chr19 = total_bps /59128983)
```

```{r summarizewidth-code-check}
grade_code()
```

### Exercise 5b:  

> **Exercise 5b**: To plot the `fraction_chr19` as bar chart, pipe the output of the code below into ggplot.  
> We instruct the bar function to plot the actual values with: `stat = "identity"`  

```{r prepare-plotsummarizewidth, message = F}
monocytes_metadata <- as.data.frame(mcols(monocytes_all))
monocytes_metadata$peak_size <- width(monocytes_all)
```

```{r plotsummarizewidth, exercise = T, message = F, exercise.eval = F}
# plot the fraction covered in a bar chart
monocytes_metadata %>%  group_by(chip) %>% 
  summarise(total_bps = sum(peak_size),  
            fraction_chr19 = sum(peak_size) /59128983) %>% 
  ggplot(.)+ 
  __(mapping = aes(x = __, y = __, fill = chip), stat = "identity")+
  theme_bw()+
  theme(legend.position = "none")
```

```{r plotsummarizewidth-hint-1, echo = F, include = F}
monocytes_metadata %>%  group_by(chip) %>% 
  summarise(total_bps = sum(peak_size),  
            fraction_chr19 = sum(peak_size) /59128983) %>% 
ggplot(.)+ 
  geom_bar(mapping = aes(x = chip ))
```

```{r plotsummarizewidth-hint-2, include = F}
monocytes_metadata %>%  group_by(chip) %>% 
  summarise(total_bps = sum(peak_size),  
            fraction_chr19 = sum(peak_size) /59128983) %>% 
ggplot(.)+ 
  geom_bar(mapping = aes(x = chip ))
```

```{r plotsummarizewidth-solution}
monocytes_metadata %>%  group_by(chip) %>% 
  summarise(total_bps = sum(peak_size),  
            fraction_chr19 = sum(peak_size) /59128983) %>% 
  ggplot(.)+ 
  geom_bar(mapping = aes(x = chip, y = fraction_chr19, fill = chip), stat = "identity")+
  theme_bw()+
  theme(legend.position = "none")
```

```{r plotsummarizewidth-code-check}
grade_code()
```

```{r mcsummarizedwidth}
question("Which type of peaks covers relativley more bp in chromosomes 9?",
         answer("narrow peak ChIP-seq peak datasets"),
         answer("broad domain ChIP-seq peak datasets", correct = T),
         allow_retry = T)
```

**These summary characteristics may suggest that H3K4me3 is relatively sparse (relative compared to the other marks) but that doesn't mean it isn't functional. Several analyses can inform us about the functionality of ChIP-seq marks. Let's start with their enrichment in promoters.**.
<br>

***
<br>


## 2.4 Overlap analysis   
### 2.4.1 Detect overlap with GenomicRanges       
To understand the function of a ChIPped histone mark or factor often want to know whether it is enriched in a particular genomic element. To find out, you need to calculate a quantitative summary of its genome-wide distribution across the different elements. By comparing this distribution to the genome-wide coverage of these different elements (null hypothesis), we can test for enrichment of the mark or factor.   
<br>
The genomic elements are defined in a reference file. You can use various reference files for this exercise: from transcript-oriented objects, to functional elements from a database like ENCODE, to a custom one.   
<br>
In the coming exercise, you will first quantify the overlap between H3K4me3 peaks and promoters and, subsequently, between H3K4me3 peaks and several different genomic elements simultaneously.   
<br>
To identify and count overlap between two sets of GRanges objects (e.g. H3K4me3 peaks and promoters) you can use function from the GenomicRanges package:  
<br>
**countOverlaps**: `countOverlaps(query, subject)` returns a integer vector with *the number of overlaps* for each element in the `query`.    
<br>
**subsetByOverlaps**: `subsetByOverlaps(query, subject)` extracts the elements in the `query` that overlap with at least one element in the subject.   
<br>
**findOverlaps**: `findOverlaps(query, subject)` returns a `Hits` object containing the index pairings for the overlapping elements.   

- The columns with indexes can be accessed through `queryHits(overlap_object)` and `subjectHits(overlap_object)`. These can subsequently be used to extract the corresponding peaks or regions from the objects that were used as inputs.    
- If a peak in one of the inputs overlaps with multiple peaks in the other, its index will appear multiple times in the output.  

<br>  

### 2.4.2 Overlap promoters vs h3k4me3 peaks   
To determine the overlap among H3K4me3 peaks and promoters, you first need to obtain promoter interval regions as GRanges object.  
<br>

> Run the code below to:  
>  
1. Retrieve the genomic coordinates of all genes from the `TxDb.Hsapiens.UCSC.hg38.knownGene` database package. The output `genes` contains the coordinates of the outermost UTR boundaries and the Entrez gene identifier for each gene.   
2. Use the `resize()` function to resize the width of `genes` such that you are left with the 1st bp: the TSS. Write the output to a new object called `tss`.    
* Hit "Run Code" to perform these steps and show a summary of the object `tss` and check that the window size is indeed 1bp.    

```{r retrieve_genes_txdb, exercise = T}
# load the txdb package which holds transcript-based gene models of hg38 genome  
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene 

# extract gene coordinates, filter for genes on chromosome 19.   
genes <- unique(genes(txdb, filter = list(tx_chrom = "chr19")))

# identify TSS as the most 5' bp
# sidenote: in this case we define 1 TSS per gene even though we know that genes have multiple TSSs  
tss <- GenomicRanges::resize(genes, width = 1, fix = "start")

# show first 3 lines of the tss object
head(tss, n = 3)

# check the tss size
all(width(tss) == 1)

```

### Exercise 6a 

> **Exercise 6a:** How many genes are encoded on chromosome 19?    

```{r q6a_genes, exercise = T}
#  How many regions do you have are stored in `promoters`? 

```

<div id="q6a_genes-hint">
**Hint:** You may want to use the `length()` function.  
</div>

```{r q6a_genes-solution, eval = F}
length(genes)
```

```{r q6a_genes-check, eval = F}
grade_result(
 pass_if(~identical(.result, length(genes)))
 )
```

> Subsequently:  
>  
3. Use the `resize()` function again but this time use `tss` as input and extend the window with 1000bp while fixating the end of the window with `fix = "end"`. `resize()` takes the strand orientation of the gene into account and fixing the end esures that the 1000bp window is set upstream of the TSS. Write the output to a new object called `promoters`.  
4. Use `resize()` for a third time to change the 1000bp window in `promoters` into a 1200bp window. With `fix = "start"` you extend the window to 200bp downstream of the TSS this time. Use the output to overwrite the original `promoters` object.  
* Hit "Run Code" to perform these steps, show a summary of `promoters`, and check that the resulting window is indeed 1200bp wide.   

```{r retrieve_promoters, exercise = T}
# consider 1kb upstream and 200bp downstream the TSS as promoter
promoters <- GenomicRanges::resize(tss, width = 1000, fix = "end")
promoters <- GenomicRanges::resize(promoters, width = 1200, fix = "start")

# show first 3 lines of the promoters object
head(promoters, n = 3)
```
<br>

### Exercise 6b 

> **Exercise 6b:** Write one-line of code to check that the size of the interval windows in `promoters` is indeed 1200 bp  

```{r q6b_promoters, exercise = T}
# check the promoter size
all(width(promoters) == 1200)
```

<div id="q6b_promoters-hint">
**Hint:** Look at the chunk above where you checked the tss window size to be 1bp   
</div>

```{r q6b_promoters-solution}
all(width(promoters) == 1200)
```

```{r q6b_promoters--code-check}
grade_code()
```


### Exercise 6c  

> We want to know how many of the promoters overlap with a H3K4me3 ChIP-seq peak and vise versa.    

> **Exercise 6c:** Use `findOverlaps()` to determine the overlap between `monocytes_h3k4me3` (query) and  `promoters` (subject).   
> 
> * You need to hit "Run Code" to be able to see the output of `show()`   


```{r q6c_overlap, exercise = T}
#exercise.setup = "prepare_exercise6"}
# Find overlap between monocytes_h3k4me3 peaks and promoters
overlap <- ___(query = ___, subject = ___)

# print the overlap output
show(___)
```

```{r q6c_overlap-solution, eval = F}
# Find overlap between monocytes_h3k4me3 peaks and promoters
overlap <- findOverlaps(query = monocytes_h3k4me3, subject = promoters)

# print the overlap output
show(overlap)
```

```{r q6c_overlap-code-check, eval = F}
grade_code()
```
<br>
The Hits object "overlap" reports the indices of `monocytes_h3k4me3` and `promoters` that overlap. If a peak or a promoter overlaps several times, each overlap will be reported in a new row.  
<br>

### Exercise 6d      

> **Exercise 6d:** What fraction of promoters is part of the overlap?  


```{r prepare_exercise6}
overlap <- findOverlaps(query = monocytes_h3k4me3, subject = promoters)
```

```{r q6d_overlap, exercise = T, exercise.setup = "prepare_exercise6"}
# Extract the unique promoter indices
unique_promoters <- unique(___(overlap))

# How many of these unique promoters do you have?
unique_promoter_count <- ___(unique_promoters)

# Print the resulting number
unique_promoter_count

# What fraction of promoters is part of the overlap?  
unique_promoter_count/__(promoters)
```

<div id="q6d_overlap-hint">
Use `queryHits()` and `subjectHits()` to extract the indices of overlapping peaks and promoters from `overlap`, respectively.  
</div>

<div id="q6d_overlap-hint">
Use `unique()` to minimize this output to unique peaks. 
</div>

<div id="q6d_overlap-hint">
Use `length()` to count the number of unique indices of the query and the subject. 
</div>

```{r q6d_overlap-solution, eval = F}
# Extract the unique promoter indices
unique_promoters <- unique(subjectHits(overlap))

# How many of these unique promoters do you have?
unique_promoters_count <- length(unique_promoters)

# Print the resulting number
unique_promoters_count

# What fraction of promoters is part of the overlap?  
unique_promoters_count/length(promoters)
```

```{r q6d_overlap_textbox, echo = FALSE}
question_text(
  "Enter the number of promoters that are part of the overlap:",
  answer("1729", message = "This is the total number of promoters. Find the ones part of the overlap with subjectHits() unique() and length()"),
  answer("1123", correct = TRUE),
  answer("1256", message = "This is the length of the overlap object, select the subject and reduce with unique."),
  answer("1008", message = "This is number of unique H3K4me3 peaks that are part of the overlap. Make sure you use subjectHits() and not queryHits() function."),
  allow_retry = TRUE)
```

```{r q6d_overlap_enterfraction, exercise = T}
# enter the fraction of promoters that are part of the overlap, round to 3 decimal places:  


```

```{r q6d_overlap_enterfraction-solution}
round(0.6495084,3)
```

```{r q6d_overlap_enterfraction-check}
grade_result(
  pass_if(~identical(.result,round(0.6495084,3))))
```


### Exercise 6e

> **Exercise 6e:** And what fraction of the h3k4me3 peaks are part of the overlap?  

```{r q6e_overlap, exercise = T, exercise.setup = "prepare_exercise6"}
# Extract the unique peaks
unique_peaks <- unique(___(overlap))

# How many of these unique peaks do you have?
unique_peaks_count <- ___(unique_peaks)

# Print the resulting number
unique_peaks_count

# What fraction of peaks is part of the overlap?  
unique_peaks_count/__(__)
```

```{r q6e_overlap-solution, eval = F}
# Extract the unique peaks
unique_peaks <- unique(queryHits(overlap))

# How many of these unique peaks do you have?
unique_peaks_count <- length(unique_peaks)

# Print the resulting number
unique_peaks_count

# What fraction of peaks is part of the overlap?  
unique_peaks_count/length(monocytes_h3k4me3)
```

```{r q6e_overlap_textbox, echo = FALSE}
question_text(
  "Enter the number of H3K4me3 peaks that are part of the overlap:",
  answer("2838", message = "This is the total number of H3K4me3 peaks. Find the ones part of the overlap with subjectHits() unique() and length()"),
  answer("1008", correct = TRUE),
  answer("1256", message = "This is the length of the overlap object, select the subject and reduce the output with unique()."),
    answer("1123", message = "This is number of unique promoter regions that are part of the overlap. Make sure you use queryHits() and not the subjectHits() function."),
  allow_retry = TRUE)
```

```{r q6e_overlap_enterfraction, exercise = T}
# enter the fraction of promoters that are part of the overlap, round to 3 decimal places:  


```

```{r q6e_overlap_enterfraction-solution, echo = F}
round(0.3551797,3)
```

```{r q6e_overlap_enterfraction-check}
grade_result(
  pass_if(~identical(.result,round(0.3551797,3))))
```

<br>
**Let's plot this overlap in a venndiagram.**   

### Exercise 7  

> Plot the overlap among promoters and H3K4me3 peaks with the `plot.pairwise.venn()` function of the `VennDiagram` package.

```{r prepare_exercise7}
overlap <- findOverlaps(query = monocytes_h3k4me3, subject = promoters)
# unique peaks 
unique_peaks <- unique(queryHits(overlap))
unique_peaks_count <- length(unique_peaks)
# unique promoters
unique_promoters <- unique(subjectHits(overlap))
unique_promoters_count <- length(unique_promoters)
# common
common_counts <- min(unique_promoters_count, unique_peaks_count)
```

> **Exercise 7a:**   
> Use the minimum of the two 'unique counts' as the number of 'common peaks' for our venn diagram.  
 
```{r q7a_minimumoverlap, exercise = T, exercise.setup = "prepare_exercise7"}
# Determine the minimum from unique_peak_count and unique_prmoter_count
# assign the output with name "common_counts"
# place the code in brackets which will ensure that the output is not only assigned to "common_counts" but also printed in the console. 

(___)

```

<div id="q7a_minimumoverlap-hint">
Use `min()` to determine the minimum given a string of values  
</div>

<div id="q7a_minimumoverlap-hint">
`min(unique_promoter_count, unique_peak_count)`
</div>

```{r q7a_minimumoverlap-solution}
common_counts <- min(unique_promoter_count, unique_peaks_count)
```

```{r q7a_minimumoverlap-check}
grade_result(
  pass_if(~identical(.result,1008))
  )
```

> **Exercise 7b:**   
> Complte the the `plot.pairwise.venn()` code below to visualize these counts in a venn diagram. The `plot.pairsiwe.venn()` function needs two "areas" that represent the total counts (overlapping and not-overlapping) of each element, and a count for the overlap.  
>
> * Hit "Run Code" to ensure that the venn diagram is plotted.  

```{r q7b_plotvenn, exercise = T, exercise.setup = "prepare_exercise7"}
# call a new plotting area
grid.newpage()

# Plot the overlap in a venn diagram
plot.pairwise.venn( 
           area1=___(monocytes_h3k4me3),
           area2=___(promoters), 
           cross.area=___, 
           category=c("H3K4me3", "Promoters"), 
           fill=c("red", "gray"), 
           cat.cex=1.2)
```

<div id="q7b_plotvenn-hint">
Use `length()` for area1 and area2
</div>

<div id="q7b_plotvenn-hint">
use `common_counts` for the "cross.eara"  
</div>


```{r q7b_plotvenn-solution}
# call a new plotting area
grid.newpage()

# Plot the overlap in a venn diagram
plot.pairwise.venn( 
   area1=length(monocytes_h3k4me3),
   area2=length(promoters), 
   cross.area=common_counts, 
   category=c("H3K4me3", "Promoters"), 
   fill=c("red", "gray"), 
   cat.cex=1.2)
```

```{r q7b_plotvenn-code-check}
grade_code()
```

<br>
*"I thought H3K4me3 was a promoter mark?! Why do we have so many H3K4me3 peaks that do not overlap with a promoter?!"* We will come back to this question shortly (you may already formulate your own hypothesis.).  
<br>
**This was a relatively simple, 1-to-1 comparison. In practice, to understand the function of a ChIPped mark or factor, you also want to know which other features are covered by this mark and therefore repeat the above exercise with other genomic features besides promoters. Let's look at such an analysis where all the comparisons are performed at once.**   

### 2.4.3 Overlap with multiple genomic features    
You will expand the analysis we started above and identify overlap with of H3K4me3 peaks with promoters, gene downstream regions, 5UTRs, "threeUTRs", "Exons", "Introns" 
<br>
```{r prepare_exercise8}
# we need the `TxDb` object and limits its active chromosomes to chromosome 19
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
seqlevels(txdb) <- "chr19"

# laod package to annotate peaks   
library(ChIPpeakAnno)   
```

### Exercise 8: 

> **Exercise 8**  
> Plot the percentage of features with the mark as barplot and as piechart  
> 
> - Access the percent values in `h3k4me3_features` using the $ operator.  
> - For plotting use `pie()` and `barplot()`.

```{r q13a_anno, exercise = T }
# calculate the overlap with features
h3k4me3_features <- assignChromosomeRegion(monocytes_h3k4me3, TxDb=txdb, precedence = c("Promoters","immediateDownstream", "fiveUTRs", "threeUTRs", "Exons", "Introns" ), nucleotideLevel=FALSE)
# show the results
h3k4me3_features

# make pie-chart

```

```{r q13a_anno-solution, eval = F}
# calculate the overlap with features
h3k4me3_features <- assignChromosomeRegion(monocytes_h3k4me3, TxDb=txdb, precedence = c("Promoters","immediateDownstream", "fiveUTRs", "threeUTRs", "Exons", "Introns" ), nucleotideLevel=FALSE)
# show the results
h3k4me3_features

# make pie-chart
pie(h3k4me3_features$percentage)
```

```{r q13a_anno-code-check, eval = F}
grade_code()
```


```{r q13b_anno, exercise = T}
# this chunk no longer exists: exercise.setup = "anno_h3k4me3_prep"}

# make barplot
bp <- ..(..$.., ylab="%")
# add percentages to the bars with text()  
text(bp, h3k4me3_features$percentage, signif(h3k4me3_features$percentage, 4), pos=1, main = "Mono h3k4me3 in features")
```

```{r q13anno-solution, eval = F}
# make barplot
bp <- barplot(h3k4me3_features$percentage, ylab="%", las = 2)
# add percentages to the bars with text()  
text(bp, h3k4me3_features$percentage, signif(h3k4me3_features$percentage, 4), pos=1, main = "Mono h3k4me3 in features")
```

```{r q13anno-code-check , eval = F}
grade_code()
```
  

**Is there a significant enrichment of h3k4me3 in promoters?**    
<br>
To answer this question, we compare the fraction of promoters with a h3k4me3 peak with the chromosome 19-wide fraction of promoters.  
<br>
If h3k4me3 is not enriched at promoters, we would expect that the fraction of promoters with a h3k4me3 peak is in the same range as the fraction of promoters on chromosome 19. (This is our **null hypothesis of no enrichment**).  
<br>
To calculate the chromosome 19-wide fraction of promoters we identify the total number of bps covered by a promoter. As some promoters may overlap we first *reduce* `promoters` to non-overlapping intervals.     
<br>
```{r fraction_promoters, echo = T, eval = F}
# total number of bps covered by promoters
total_bp_prom <- sum(width(GenomicRanges::reduce(promoters)))
# chromosome 19-wide fraction of promoters 
(prom_fraction_chr19 <- total_bp_prom/seqlengths(promoters)["chr19"])
```
<br>
Promoters make up 3.4% of this chromosome but nearly 65% of all promoters overlap with h3k4me3 peaks. This looks like a strong enrichment. We can test whether the observed fraction is indeed larger than expected with a binomial test, in r we use the function `binom.test(x, n, p)` for this:  

- `x` = number of successes, number of promters with h3k4me3 peak  
- `n` = total number of trails, total number of h3k4me3 peaks  
- `p` = expected probability of success, in this case the fraction of promoters in chromosome 19  

<br>

> *Background*: The binomial test is run when an experiment has two possible outcomes (i.e. success/failure) and you have an idea about what the probability of success is. Success in this case is overlap and our expectation is that 3.4% of the cases show overlap. The test calculates the probability of getting a desired outcome with a specific sample size `n`. 

>**Exercise 12**  
Use a binomial test to test for enrichment of h3k4me3 at promoters.  
> 
> - Use the function `binom.test(x, n, p, alternative = "greater")` to call the test  
> - We set `alternative = "greater"` because we test for *enrichment* and our alternative hypothesis is that the true probability is *larger* than the expected probability.  

<br>
```{r q12_binomtest, exercise = T, exercise.setup = "q6d_overlap", exercise.setup = "fraction_promoters"}
# binomial test for enrichment of h3k4me3 peaks in promoters:  
binom.test(length(unique(___(overlap))), length(___), prom_fraction_chr19, alternative = "greater" )

```

```{r q12_binomtest-solution, eval = F}
binom.test(length(unique(subjectHits(overlap))), length(monocytes_h3k4me3), prom_fraction_chr19, alternative = "greater" )
```

```{r q12_binomtest-code-check, eval = F}
grade_code()
```
<br>
The binomial test shows a p-value < 2.2e-16 and a confidence interval that excludes the expected 0.034. We therefore reject the H0 of no enrichment.  
<br>
In the genome browser we also observed H3K27ac often at promoters. Is this mark enriched in these regions?  

>**Exercise 13**  
Use a binomial test to test for enrichment of H3K27ac at promoters.  
> 
> - First, use findOverlaps to detect the overlap between intervals reported in monocytes_h3k37 and promoters
> - Use the function `binom.test(x, n, p, alternative = "greater")` to call the test  
> - We set `alternative = "greater"` because we test for *enrichment* and our alternative hypothesis is that the true probability is *larger* than the expected probability.  

```{r overlap_exercise13} 
# this chunk no longer exists: exercise.setup = 'prep-txdbindiv'}

# prepare data for exercise 13

# identify TSS (in this case 1 per gene even though we know that genes have multiple TSSs)
tss <- resize(genes, width = 1, fix = "start")
# consider 1kb upstream and 200bp downstream the TSS as promoter
promoters <- resize(tss, width = 1000, fix = "end")
promoters <- resize(promoters, width = 1200, fix = "start")

# load the monocyte data
rdata = system.file("extdata", "week2", "prepared_rds", "blueprint_monocyte_chr19_granges.RData", package = "learnr.proto")
load(rdata)
#load("www/prepared_rds/blueprint_monocyte_chr19_granges.RData")

# fraction of promoters on chr19
prom_fraction_chr19 <- sum(width(GenomicRanges::reduce(promoters)))/seqlengths(promoters)["chr19"]
```

```{r q13a_h3k27ac, exercise = TRUE, exercise.setup = "overlap_exercise13" }
# find overlap between monocytes_h3k27ac and promoters
overlap2 <- ___
```

```{r q13a_h3k27ac-solution, eval = F}
overlap2 <- findOverlaps(query = monocytes_h3k27ac, subject = promoters)
```

```{r q13b_h3k27ac, exercise = TRUE, exercise.setup = "overlap_exercise13", exercise.setup = "q13a_h3k27ac"}
# binomial test for enrichment of H3K27ac peaks in promoters
# `prom_fraction_chr19` holds the fractio of promoters in chromosome 19
..(..(..(..(..))), ..(..), prom_fraction_chr19, alternative = "greater" )
```

```{r q13b_h3k27ac-solution, eval = F}
# binomial test for enrichment of H3K27ac peaks in promoters:  
binom.test(length(unique(subjectHits(overlap2))), length(monocytes_h3k27ac), prom_fraction_chr19, alternative = "greater" )
```
 
```{r q13b_h3k27ac-code-check}
grade_code()
```
<br>

>**Exercise 14:**  
Do you conclude that H3K27ac is enriched at promoters?  

```{r q14_enrichment, exercise = T, echo = T}
question("Is H3K27ac enriched at promoters?",
         answer("*Yes*", correct = T),
         answer("*No*", message = "Incorrect. Look at the p-value of the previous test.")
)
```

