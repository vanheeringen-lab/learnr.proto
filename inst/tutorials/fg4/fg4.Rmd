---
title: "Week 4: "
tutorial:      # where learnr stores the progress
  id: "FG4"    # folder name
  version: 0.1 # subfolder name
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: true
    allow_skip: true
    css: ["css/custom.css", "css/print2pdf.css"]
runtime: shiny_prerendered
description: >
  Multi line text can be put here
  for your convenience.
---


```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(learnr)     # 0.10.1.9006 (github)
  library(gradethis)  # 0.1.0.9004  (github)
  library(testthat)   # 3.0.0 
  library(tidyverse)  # 1.3.0
  library(learnr.proto)
  
  # configuration
  knitr::opts_chunk$set(echo = FALSE)
  gradethis::gradethis_setup()
  
  # data accessible to all exercises
  rdata = system.file("extdata", "week4.Rdata", package = "learnr.proto")
  load(rdata)
})
```

```{r timeout1, context="server"}
session$onSessionEnded(stopApp)

isolate({
  # obtain the session id
  # source 1: https://shiny.rstudio.com/reference/shiny/latest/session.html
  # source 2: https://stackoverflow.com/questions/18900955/get-environment-identifier-in-r
  session_id <- sub('<environment: (.*)>', '\\1', capture.output(session$userData))
  
  # # send the session ID to the log (indicates the tutorial is loaded)
  # write(paste0("Session ID: ", session_id), stderr())
  
  # send the session ID to the javascript chunk
  session$sendCustomMessage("session_id", session_id)
})

# stop the tutorial when "input[[session_id]]" is updated
observeEvent(input[[session_id]], ignoreNULL=T, {
  write(paste0("\nTutorial terminated due to inactivity.\nRestart to continue where you left off!\n"), stderr())
  stopApp()
})
```

```{js timeout2}
// This chunk stops the tutorial if it has been idle for too long

// Situation: We need to stop inactive tutorials to prevent the server from grinding to a halt.
// Problem: refreshing the tutorial and closing the browser send the same signal to shiny.
// since we cannot distinguish the two, this signal cannot be used to stop the tutorial.
// Solution: Use a timeout system. 
// Method: this chunk will update shiny variable "input[[session_id]]" 
//   when the session has been running idle for longer than "timeoutSec" seconds.
// This signal is then be used by Shiny (server-side) to stop the session.

// source1: https://community.rstudio.com/t/keeping-track-of-idle-time-during-app-usage/1735
// source2: https://bookdown.org/yihui/rmarkdown/language-engines.html#javascript-and-css
$(function() {
  var timeoutSec = 5*60;
  var idleTimer;

  // receive this session's ID
  Shiny.addCustomMessageHandler("session_id", function(s_id) {
    session_id = s_id;  // assigns the variable globally
  });

  // assign session ID as reactive variable "input[[session_id]]" 
  function onTimeout() {
    alert("Tutorial stopped due to inactivity.\nRestart to continue where you left off!")
    Shiny.setInputValue(session_id, "TRUE");
  }

  function startIdleTimer() {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(onTimeout, timeoutSec * 1000);
  }
  
  $(document).on('shiny:message shiny:inputchanged', startIdleTimer);

})();
```

```{js print2pdf1, context="server"}
$(document).on('shiny:inputchanged', function(event) {
  if (event.name === 'print2pdf') {
    window.print();
  }
});
```

```{r print2pdf2}
actionButton("print2pdf", "Print page", style="opacity: .7; color: #000;")
```
