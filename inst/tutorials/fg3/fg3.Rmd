---
title: "Week 3: "
tutorial:      # where learnr stores the progress
  id: "FG3"    # folder name
  version: 0.1 # subfolder name
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: true
    allow_skip: true
    css: css/custom.css
runtime: shiny_prerendered
description: >
  Multi line text can be put here
  for your convenience.
---


```{r setup, include=FALSE}
library(learnr)     # 0.10.1.9006 (github)
library(gradethis)  # 0.1.0.9004  (github)
library(testthat)   # 3.0.0 
library(tidyverse)  # 1.3.0
library(learnr.proto)

# configuration
knitr::opts_chunk$set(echo = FALSE)
gradethis::gradethis_setup()

# data accessible to all exercises
rdata = system.file("extdata", "week3.Rdata", package = "learnr.proto")
load(rdata)
```

```{r timeout1, context="server"}
isolate({
  # obtain the session id
  # source 1: https://shiny.rstudio.com/reference/shiny/latest/session.html
  # source 2: https://stackoverflow.com/questions/18900955/get-environment-identifier-in-r
  session_id <- sub('<environment: (.*)>', '\\1', capture.output(session$userData))
  
  # # send the session ID to the log (indicates the tutorial is loaded)
  # write(paste0("Session ID: ", session_id), stderr())
  
  # send the session ID to the javascript chunk
  session$sendCustomMessage("session_id", session_id)
})

# stop the tutorial when "input[[session_id]]" is updated
observeEvent(input[[session_id]], ignoreNULL=T, {
  write(paste0("\nTutorial terminated due to inactivity.\nRestart to continue where you left off!\n"), stderr())
  stopApp()
})
```

```{js timeout2}
// This chunk stops the tutorial if it has been idle for too long

// Situation: We need to stop inactive tutorials to prevent the server from grinding to a halt.
// Problem: refreshing the tutorial and closing the browser send the same signal to shiny.
// since we cannot distinguish the two, this signal cannot be used to stop the tutorial.
// Solution: Use a timeout system. 
// Method: this chunk will update shiny variable "input[[session_id]]" 
//   when the session has been running idle for longer than "timeoutSec" seconds.
// This signal is then be used by Shiny (server-side) to stop the session.

// source1: https://community.rstudio.com/t/keeping-track-of-idle-time-during-app-usage/1735
// source2: https://bookdown.org/yihui/rmarkdown/language-engines.html#javascript-and-css
$(function() {
  var timeoutSec = 5*60;
  var idleTimer;

  // receive this session's ID
  Shiny.addCustomMessageHandler("session_id", function(s_id) {
    session_id = s_id;  // assigns the variable globally
  });

  // assign session ID as reactive variable "input[[session_id]]" 
  function onTimeout() {
    alert("Tutorial stopped due to inactivity.\nRestart to continue where you left off!")
    Shiny.setInputValue(session_id, "TRUE");
  }

  function startIdleTimer() {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(onTimeout, timeoutSec * 1000);
  }
  
  $(document).on('shiny:message shiny:inputchanged', startIdleTimer);

})();
```

1. 




In this part of the analysis, we show how to generate plots displaying the distribution of ChIP-seq signal around certain genomic positions, here a set of promoter regions. These include a heatmap representation and an average profile for H3K27ac signal at promoters overlapping a peak of H3K27ac identified by MACS. These are one of the most frequently performed analysis steps in ChIP-seq experiments.

In the previous section, we have identified promoters overlapping a H3K27ac peak (the pos.TSS object). In order to get a comprehensive view of the distribution of H3K27ac around the corresponding TSS, we extend the analysed region to ±1000 bp around the TSS. We divide each of these 2000 bp regions into 20 bins of 100 bp length each and order the bins with increasing position for genes on the ’+’ strand and decreasing for genes on the ’-’ strand.

Next, we tile the promoter regions with consecutive 100bp tiles. For each region, we order the tiles according to the gene orientation. We create 20 tiles per promoter region.


### large daomain H3K27me3  
- overlap met H3K4me1
- welke genen zijn bivalent  

## structure
1. gemiddelde signaal rond TSS
2. groepering naar genexpressielevel per quantile voor H3K4me3
3. Hoe zit dat bij H3K27me3 (niet bij heel hoge expressie, breed signaal, je pakt maar een stukje)
4. Hoe zit dit er uit als we elk datapunt bekijken in dotplot/scatterplot --> het is een trend en geen harde waarheid komt (deels) door invloed van andere marks = combinatorial markings. 
5. Heatmap van histone marks at TSS random. Dan geordend op genexpressie niveau.  

<br>
Chromatin states - re-occurring, co-localization of histone marks and factors - mapping of epigenomic marks, such as histone modifications, histone variants, regions of open chromatin, and related marks, has emerged as a powerful means to annotate genomes, to identify putative regulatory elements, and to study their changing activity across different cell types and in human disease1,2,3,4. Individual marks can be studied in isolation, either through aggregation of their genome-wide signal tracks relative to a set of predetermined annotations5, such as transcription start sites or exon boundaries, or by discovery of narrow peaks or broader domains in which the mark is present in greater frequency than that of the surrounding regions6. However, additional information can be gained by studying combinations of multiple marks in their spatial context. Such patterns, termed 'chromatin states', often capture known classes of genomic elements, such as promoters, enhancers, and transcribed, repressed, and repetitive regions7, and can also capture novel classes or subclasses of elements. (https://www.nature.com/articles/nprot.2017.124)
### Exercise 9  
```{r}
library(genomation)
library(pheatmap)
library(RColorBrewer)
chromhmm_file <- system.file("extdata", "week2", "blueprint", "chromhmm", "C000S5H1_12_12_Blueprint_release_201608_dense_chr19.bed", package = "learnr.proto")
chromhmm <- rtracklayer::import(chromhmm_file)
# 12 states - which is what?  
table(chromhmm$name)  
chromhmm_list <- split(chromhmm, chromhmm$name,drop=TRUE)

mono_list <- GRangesList(monocytes_list, compress = F)

chrommhmm_anno_list <- annotateWithFeatures(mono_list,chromhmm_list)
heatTargetAnnotation(chrommhmm_anno_list)+
  coord_flip()+
  scale_fill_gradient(low = "white", high = "blue")
  
mat=heatTargetAnnotation(chrommhmm_anno_list,plot=FALSE)



pheatmap(mat = mat, 
         color = c("white", brewer.pal("Reds", n =9)),
         cluster_cols = F)

      
#BiocManager::install("pheatmap")

```
State1.- Repressed Polycomb High signal H3K27me3 -A 
State2.- Repressed Polycomb Low signal H3K27me3 - A
state3.- Low signal
State4.- Heterochromatin High Signal H3K9me3 - B
State5.- Transcription High signal H3K36me3 - C 
State6.- Transcription Low signal H3K36me3 -C
State7.- Genic Enhancer High Signal H3K4me1 & H3K36me3
State8.- Enhancer High Signal H3K4me1
State9.- Active Enhancer High Signal H3K4me1 & H3K27Ac - D
State10.- Distal Active Promoter (2Kb) High Signal H3K4me3 & H3K27Ac & H3K4me1 - D
State11.- Active TSS High Signal H3K4me3 & H3K4me1 - E 
state12.- Active TSS High Signal H3K4me3 & H3K27Ac - E

## 2.5 Annotation of ChIP-seq peaks
### 2.5.1 Distance to TSS     
In this part of the analysis you will assign peaks to the closest TSS.  
<br>
The `nearest(x, subject)` function from the `GenomicRanges` package finds the nearest regions to `x` within the set of regions reported in `subject`. For each region in `x` it reports the index of the nearest neigbor range in `subject`.  
<br>
The `distanceToNearest(x, subject)` function also reports the distance between intervals in `x` and the nearest neighbor in `subject`. The function outputs a `Hits` objects with absolute distances.  
<br>
In this case, `x` are the peaks and the TSSs are the `subject`. 
<br>

### Exercise 9  
You will identify the nearest TSS for H3K4me3 and H3K27ac peaks, plot the distances as a histogram and identify the number of regions TSSs that overlap.  

> **Exercise 9a** Use `distanceToNearest()` to obtain the distance between h3k4me3 peaks and the nearest TSS.  

```{r q15_distance_tss, exercise = TRUE, exercise.eval = F, error = T}
### TSS locations are stored in object 'tss_chr19' 

# calculate the distances from peaks to tss
h3k4me3_to_tss <- ..(.., ..)
```

```{r q15_distance_tss-solution,  eval = F}
rdata = system.file("extdata", "week2", "prepared_rds", "txdb_annotation_chr19_genes_tx_pr_tss_granges.RData", package = "learnr.proto")
load(rdata)

rdsfile = system.file("extdata", "week2", "prepared_rds", "txdb_annotation_chr19_grangeslist.rds", package = "learnr.proto") 
annotation_chr19_gr <- readRDS(rdsfile)

mat_annotation_chr19_gr <- make_comb_mat(annotation_chr19_gr)
UpSet(mat_annotation_chr19_gr)

# calculate the distances from peaks to tss
h3k4me3_to_tss <- distanceToNearest(monocytes_h3k4me3, tss)
```

```{r q15_distance_tss-code-check, eval = F}
grade_code()
```
<br>
Let's look at the resulting `Hits` object.  
<br>
```{r look at hits, echo = T}
rdata = system.file("extdata", "week2", "prepared_rds", "txdb_annotation_chr19_genes_tx_pr_tss_granges.RData", package = "learnr.proto")
load(rdata)
tss <- resize(genes, width = 1, fix = "start")
# calculate the distances from peaks to tss
h3k4me3_to_tss <- distanceToNearest(monocytes_h3k4me3, tss)

# show object h3k4me3_to_tss
show(h3k4me3_to_tss)

# summary of distances
summary(mcols(h3k4me3_to_tss)[,1])

# plot the distribution of distances
boxplot(mcols(h3k4me3_to_tss)[,1])
```
<br>  

### 2.5.2 Find associating gene  
You can use this `Hits` object to subset peaks to those that are less than 10 Kb away from the TSS. You can than use the function `subjectHits()` to get the genes associated to each peak.  
<br>

>**Exercise 16**  
Subset the h3k4me3_to_tss for distances =< 10kb and select the associated genes from `genes` object.  

```{r prepare_closegene_q16}
rdata = system.file("extdata", "week2", "prepared_rds", "txdb_annotation_chr19_genes_tx_pr_tss_granges.RData", package = "learnr.proto")
load(rdata)
tss <- resize(genes, width = 1, fix = "start")
# load("www/prepared_rds/txdb_annotation_chr19_genes_tx_pr_tss_granges.RData")  
h3k4me3_to_tss <- distanceToNearest(monocytes_h3k4me3, tss)
```


```{r q16a_closegenes, eval = F, exercise = T, exercise.setup = "prepare_closegene_q16" }
# save the distances in a vector
distances <- mcols(h3k4me3_to_tss)[,1]

# subset h3k4me3_to_tss by distance
h3k4me3_to_tss_close <- ..[..,..]
```

```{r q16a_closegenes-solution, eval = F}
# save the distances in a vector
distances <- mcols(h3k4me3_to_tss)[,1]

# subset h3k4me3_to_tss for distances <= 10000
h3k4me3_to_tss_close <- h3k4me3_to_tss[distances <= 10000,]
```

```{r q16a_closegenes-code-check, eval = F}
grade_code()
```


```{r 16b_closegenes, exercise = T, exercise.setup = "q16a_closegenes" }
# obtain the genes
monocytes_h3k4me3_genes <- unique(genes[..(..)])

# look at the output
show(monocytes_h3k4me3_genes)
```
 
```{r 16b_closegenes-solution, eval = F}
# obtain the genes
monocytes_h3k4me3_genes <- unique(genes[subjectHits(h3k4me3_to_tss_close)])

# look at the output
show(monocytes_h3k4me3_genes)
```

```{r q16b_closegenes-code-check, eval = F}
grade_code()
```

<br>
Besides the distance, we are also (very!) interested in the distribution of the ChIP-seq signal around the TSS. You will look at that next week.  
Next week you will analyze the ChIP-seq signal around the coding body further by examining differences in the ChIP-seq *signal intensity* around the TSS and across the coding body.  
### 2.5 Identify the nearest TSS  



## Summary and introducing next week's topic   

