---
title: "Week 3: Analyzing ChIP-seq signal strength"
tutorial:      # where learnr stores the progress
  id: "FG3"    # folder name
  version: 0.1 # subfolder name
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: true
    allow_skip: true
    css: css/custom.css
runtime: shiny_prerendered
description: >
  Multi line text can be put here
  for your convenience.
---


```{r setup, include=FALSE}
library(learnr)     # 0.10.1.9006 (github)
library(gradethis)  # 0.1.0.9004  (github)
library(testthat)   # 3.0.0 
library(tidyverse)  # 1.3.0
library(learnr.proto)

library(IRanges)
library(GenomicRanges)
library(rtracklayer)
library(GenomicFeatures)
library(genomation)
library(ggthemes)
#library(org.Hs.eg.db)


# load the txdb package which holds transcript-based gene models of hg38 genome  
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene 
seqlevels(txdb) <- "chr19"

# configuration
knitr::opts_chunk$set(echo=FALSE, message=FALSE)
gradethis::gradethis_setup()

# data accessible to all exercises
rdata = system.file("extdata", "week2.Rdata", package = "learnr.proto")
load(rdata)
monocytes_all <- unlist(monocytes_list)
monocytes_all$chip <- names(monocytes_all)
monocytes_list <- GRangesList(monocytes_list, compress=FALSE)

# chr19_windows_1bp <- tileGenome(seqinfo(txdb), tilewidth = 10, cut.last.tile.in.chrom =TRUE)
tss_chr19 <- unique(promoters(genes(txdb), upstream=100, downstream=0)) 
tss_chr19  <- resize(tss_chr19, width = 1, fix = "end")
tss_chr19$name <- tss_chr19$gene_id
promoters_chr19 <- unique(promoters(genes(txdb), upstream=2000, downstream=200)) 
genes_chr19 <- unique(genes(txdb))

# sample of tss_chr19 and quantification_chr19 
# those those for which we have data in bigwig files, see extdata/prepdata.Rmd)
rdata = system.file("extdata", "week3.Rdata", package = "learnr.proto")
load(rdata)
rm(rdata)
quantification_chr19_sample <- quantification_chr19_sample %>% dplyr::rename(gene_id = entrezgene_id)
quantification_chr19_sample$expression_group <- NULL

# gene quantification chromosome 19  
rdsfile <- system.file("extdata", "week2", "prepared_rds", "blueprint_c000s5_gene_quantification_chr19.rds", package = "learnr.proto")
quantification_chr19 <- readRDS(rdsfile)
quantification_chr19 <- quantification_chr19 %>% dplyr::rename(gene_id = entrezgene_id)

## bw file locations 
bw_h3k4me3 <- system.file("extdata", "week3", "bw_chr19_tss_sample", "C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150528.chr19_chr19tss_0.4ofGenes_15kb.bw", package = "learnr.proto")
bw_h3k4me1 <- system.file("extdata", "week3", "bw_chr19_tss_sample", "C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.20150528.chr19_chr19tss_0.4ofGenes_15kb.bw", package = "learnr.proto")
bw_h3k27me3 <- system.file("extdata", "week3", "bw_chr19_tss_sample", "C000S5H2.ERX547983.H3K27me3.bwa.GRCh38.20150528.chr19_chr19tss_0.4ofGenes_15kb.bw", package = "learnr.proto")
bw_h3k27ac <- system.file("extdata", "week3", "bw_chr19_tss_sample", "C000S5H2.ERX547980.H3K27ac.bwa.GRCh38.20150528.chr19_chr19tss_0.4ofGenes_15kb.bw", package = "learnr.proto")
```

```{r timeout1, context="server"}
isolate({
  # obtain the session id
  # source 1: https://shiny.rstudio.com/reference/shiny/latest/session.html
  # source 2: https://stackoverflow.com/questions/18900955/get-environment-identifier-in-r
  session_id <- sub('<environment: (.*)>', '\\1', capture.output(session$userData))
  
  # # send the session ID to the log (indicates the tutorial is loaded)
  # write(paste0("Session ID: ", session_id), stderr())
  
  # send the session ID to the javascript chunk
  session$sendCustomMessage("session_id", session_id)
})

# stop the tutorial when "input[[session_id]]" is updated
observeEvent(input[[session_id]], ignoreNULL=TRUE, {
  write(paste0("\nTutorial terminated due to inactivity.\nRestart to continue where you left off!\n"), stderr())
  stopApp()
})
```

```{js timeout2}
// This chunk stops the tutorial if it has been idle for too long

// Situation: We need to stop inactive tutorials to prevent the server from grinding to a halt.
// Problem: refreshing the tutorial and closing the browser send the same signal to shiny.
// since we cannot distinguish the two, this signal cannot be used to stop the tutorial.
// Solution: Use a timeout system. 
// Method: this chunk will update shiny variable "input[[session_id]]" 
//   when the session has been running idle for longer than "timeoutSec" seconds.
// This signal is then be used by Shiny (server-side) to stop the session.

// source1: https://community.rstudio.com/t/keeping-track-of-idle-time-during-app-usage/1735
// source2: https://bookdown.org/yihui/rmarkdown/language-engines.html#javascript-and-css
$(function() {
  var timeoutSec = 20*60;
  var idleTimer;

  // receive this session's ID
  Shiny.addCustomMessageHandler("session_id", function(s_id) {
    session_id = s_id;  // assigns the variable globally
  });

  // assign session ID as reactive variable "input[[session_id]]" 
  function onTimeout() {
    alert("Tutorial stopped due to inactivity.\nRestart to continue where you left off!")
    Shiny.setInputValue(session_id, "TRUE");
  }

  function startIdleTimer() {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(onTimeout, timeoutSec * 1000);
  }
  
  $(document).on('shiny:message shiny:inputchanged', startIdleTimer);

})();
```

## 3.1 Introduction   
In week 2 we quantified and visualized the overlap between histone peaks and promoters and examined the association with gene expression. Although informative, we have been ignoring the actual ChIP-seq signal strengths altogether.  
<br>
This week you will investigate the relationship between histone PTMs and gene expression further by including ChIP-seq signals in your analyses. You will generate plots displaying the distribution of ChIP-seq signal around certain genomic positions, here a set of promoter regions to answer common questions like: "*What is the signal of the mark around the TSS?*", "*What is the relationship between histone ChIP-seq signal intensity and gene expression?*".  
<br>
These plots include an average signal profile and a heatmap representation. You could use dplyr-related functions and ggplot-ting to achieve this but it is much more convenient to use dedicated tools for these tasks.   
<br>
We have chosen for the [genomation](https://github.com/BIMSBbioinfo/genomation) package for this purpose because it is compatible with the file types that we have available. (Side note: there are a number of other packages to analyze ChIP-seq data we well. Incl. ChIPpeakAnno and ChIPseeker.)   
<br>
We have installed and loaded this package for you with the following code:  
```{r install_genomation, echo = T, eval =FALSE}
BiocManager::install("genomation")
library(genomation)
```

### Tutorial specs  
The exercises in this tutorial are similar to those in fg2. A brief reminder:  

- For some longer coding exercises, we left blanks as "___" that indicate where in the code you should fill in a function, object or variable. Make sure fill out all the blanks before Answer submission, they will otherwise result in errors.  
- Hit `Hint` (when provided) for clues.  
- Hit `Run Code` to test your code and preview the output.  
- Hit `Submit Answer` (if present) to submit the code. As 'submitting' not always shows the code output, we advise to use `Run Code` first. Upon hitting `Submit Answer` and when code-checking is enabled and your submitted code is different from the solution code, R will give automatic feedback that helps you correct your code.  
- Hit `Start Over` to remove any adjustments you made and start again.   
- Try to keep yourself from hitting `Solution` (when provided). This is option is sometimes provided when your code is evaluated. Only use it when you do not understand the automatic feedback given by R.   

Although we ask for specific answers or completion of specific code, you are encouraged to test your own code and use `Run Code` and `Start Over` extensively. I.e., remove the pre-coded code and write your own code for a different graph or different summary of the data. Use `Run Code` to preview the results. Unfortunately these self-thought of codes can not be evaluated. For the evaluation you need to use our pre-coded code. Hit `Start Over` to get this pre-coded code.  

#### Used resources   

- Akalin A, Franke V, Vlahovicek K, Mason C, Schubeler D (2014). “genomation: a toolkit to summarize, annotate and visualize genomic intervals.” Bioinformatics. doi: 10.1093/bioinformatics/btu775, http://bioinformatics.oxfordjournals.org/content/early/2014/12/04/bioinformatics.btu775.long
- [Genomation package vignette](http://bioconductor.org/packages/release/bioc/vignettes/genomation/inst/doc/GenomationManual.html).    
- Data was downlaoded from the [BLUEPRINT data portal](http://dcc.blueprint-epigenome.eu/#/home).    

### 3.1.1 Learning Objectives  

> At the end of week 3 you are able to:  
> 
1. Identify the nearest TSS to a histone ChIP-seq peak.  
3. Plot the distribution of distances between ChIP-seq peaks and the nearest TSS.      
2. Import coverage data from bigwig files into r.  
4. Plot the average histone ChIP-seq signal around a genomic feature like the TSS.  
5. Plot the relationship between ChIP-seq signal at the TSS and gene expression.   
6. Optionally, test for significance of the observed association.  
7. Summarize ChIP-seq signal in a heatmap figure.  
8. Order the heatmap of (7) by gene expression.  
9. Cluster the heatmap of (7) based on ChIP-seq signals of different marks.  
10. Optionally, back-analyze chromHmm output, in other words, heatmap summary of signal intensities of the different marks in chromHMM defined regions. Regions are labelled 1-12, can you, using the sig
  
## 3.2 Identify nearby TSSs  
### 3.2.1 Identify the nearest TSS   
First, let's identify the nearest TSS and plot the distance between a histone mark and its nearest TSS (in contrast to identifying strict overlap as in fg3).  

### Exercise 1    
Identify the nearest TSS for each H3K4me3 peak in monocytes.   

> **Exercise 1a**: Recap, which of the commands below imports the peaks table into a GRanges object?  

```{r qimport}
question("Which function imports the H3K4me3 peaks into a GRanges object?",
         answer("import(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed\", format = \"narrowPeak\")", correct =TRUE),
         answer("import(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed\", format = \"BED\")", message = "BED is not the right format."),
         answer("import(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed\", format = \"broadPeak\")", message = "check the file format."),
         answer("read.table(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed\", format = \"broadPeak\")", message = "read.table parses the data into a data.frame while we asked for a GRanges object."),
         allow_retry =TRUE,
         random_answer_order =TRUE)
```

### Exercise 1b  
To identify the nearest TSS, you use the function:   

`distance2NearestFeature(g.idh = [GRanges object withe peaks], tss = [GRanges object with TSSs])`  

The output is a data.frame reporting for each range in the `g.idh` object:

- its nearest TSS  
- the name of the corresponding peak and TSS  
- the distance between them. 

The fact that the output is a data.frame makes it easy for us to summarize the results with dplyr and ggplot2.      

<!-- 1. target.row = index of the peak in the GRanges object with peaks.   -->
<!-- 2. dist.to.feature = distance to the nearest TSS, negative when the peak is *upstream* of the TSS.    -->
<!-- 3. feature.name = the Entrez gene id of the corresponding gene, given in the column "names" of object `tss_chr19`.    -->
<!-- 4. feature.strand = strand of the TSS.    -->

> **Exercise 1b**: Identify the nearest TSS for each H3K4me3 ChIP-seq peak.  
> 
- TSS locations are stored in object `tss_chr19`.  
- H3K4me3 peaks in monocytes are stored in `monocytes_h3k4me3`.   
- Print the head of the resulting object to the console using `head()`.     

```{r q1_distancetss, exercise =TRUE, exercise.lines = 5, exercise.eval =FALSE, error = T}
# Identify the nearest TSS for each H3K4me3 peak  
dist_h3k4me3_to_tss <- __(g.idh = __, tss = __)

# Show the resulting object 

```

```{r q1_distancetss-hint-1}
# use the function
distance2NearestFeature()
```

```{r q1_distancetss-hint-2}
# within distance2NearestFeature define g.idh as:
g.idh = monocytes_h3k4me3
```

```{r q1_distancetss-hint-3}
# and tss as:
tss = tss_chr19
```

```{r q1_distancetss-hint-4}
# finish with
head(dist_h3k4me3_to_tss)
```

```{r q1_distancetss-check}
grade_result(
  pass_if(~identical(.result, head(distance2NearestFeature(monocytes_h3k4me3, tss_chr19))))
)
```

The `dist_h3k4me3_to_tss` reports for each H3K4me3 peak a nearest TSS. In total `r length(unique(distance2NearestFeature(monocytes_h3k4me3, tss_chr19)$feature.name))` different TSSs are reported, meaning that some peaks are assigned to the same TSS. *Which variable reports the distance between the peak and its nearest TSS?*       
<br>

>#### **Optional check**:  
<details><summary>Curious to check the matches in the genome browser?:</summary>   
<br>
You may want to check some of the matches. For example to check that positive distances are indeed peaks that are located *downstream* the TSS. To do so...  
1. View a part of the output of `dist_h3k4me3_to_tss`. For example, peaks with `dist.to.feature` above 1kb, sorted by distance, showing only the top 5 of the output by running: `dist_h3k4me3_to_tss %>% filter(dist.to.feature >= 1000) %>% arrange(dist.to.feature) %>% slice_head(n=5)`   
2. The first row reports:     
  `r distance2NearestFeature(monocytes_h3k4me3, tss_chr19) %>% filter(dist.to.feature >= 1000) %>% arrange(dist.to.feature) %>% slice_head(n=2) %>% slice_tail(n=1)`  
3. You can either look up the gene id ('feature.name' variable) in the [ncbi gene database](https://www.ncbi.nlm.nih.gov/gene/) and use the gene symbol to navigate to the right location in the UCSC genome browser.  
3. Or subset `monocytes_h3k4me3` with the given index in the 'target.index' column (805): `monocytes_h3k4me3[805]`.  
4. Go to the UCSC Genome Browser.  
5. Upload the monocytes trackhub (same as fg1): `http://mbdata.science.ru.nl/ctoenhake/edu/trackhub_monocytes/hub.txt`.    
  + Go to the tab "My Data" in the top menu.  
  + Select "Track Hubs".   
  + In the "My hubs" tab you can paste the above URL.  
  + You need to change the visibility of the tracks with "monocyte_H3K4me3_peaks" from "hide" to "pack". This can be done below the browser view. Remember to hit `Refresh`.  
6. Navigate to the gene from step 3 or the genomic region of step 4.  
  + In this example: `chr19:11577771-11577970`.    
7. Zoom out and observe or measure the location of the peak in relation to the TSS of the gene given in step 3. The name of the peak is given in the output of step 4.   
8. This confirms that **positive dist.to.feature values indicate that the H3K4me3 peaks is located *downstream* the TSS**.  
</details>  

### 3.2.2 Plot distances between ChIP peaks and features  
Having identified the nearest TSS for each H3K4me3 peak, you willsummarize the distances between H3K4me3 peaks and TSSs.  
### Exercise 2   

> **Exercise 2a:** Print a summary of the distances reported in `dist_h3k4me3_to_tss` using the `summary()` function.
> 
> * Tip: Look at the output from exercise 1b to identify the variable that stores the distances.   

```{r prepare_q2a, echo =FALSE}
 dist_h3k4me3_to_tss <- distance2NearestFeature(monocytes_h3k4me3, tss_chr19)
```

```{r q2a_summary, exercise =TRUE, exercise.eval =FALSE, error = T, exercise.setup = "prepare_q2a"}
# print a summary of the distances

```

```{r q2a_summary-hint-1}
# We want a summary of 
dist_h3k4me3_to_tss$dist.to.feature
```

```{r q2a_summary-check}
grade_result(
  pass_if(~identical(.result,summary(dist_h3k4me3_to_tss$dist.to.feature)))
)
```

### Exercise 2b  

> **Exercise 2b:** Plot the distances from `dist_h3k4me3_to_tss` using ggplot() and geom_histogram() and answer the multiple-choice question below.     
>
> * With the summary of exercise 2a in mind, play around with the `binwidth  =` parameter in `geom_histogram()`. 

>#### **Refresher**: histograms   
<details><summary>Click here for a quick explainer on histograms and the importance of the bin width or bandwidth.</summary>   
**Histograms** visualize the distribution of a single variable. Events are grouped into bins with comparable values and the number of events per bin is counted and these counts are visualized.  
<br>
Because histograms are made by binning the data, the bin width is a critical parameter that will affect the appearance of the graph. Choosing a bin width that is too small will result in a overly busy and peaky histogram making it difficult to discern the main trends. If the bin width is too large, then smaller features of the distribution may dissapear.  
<br>
In practice, if you generate a histogram, always explore multiple bin widths besides the default settings.   
<br>
In geom_histogram(), the bin width can be set by:  
> 
- Specify the parameter "binwidth", eg `binwidth = 5`   
- Specify the parameter "breaks", eg `breaks=seq(20, 50, by=2)` or `breaks=c(0,100,200)`  
</details>  

```{r q2b_plotdistances, exercise =TRUE, exercise.eval =FALSE, error = T, exercise.setup = "prepare_q2a"}
# plot the distances as histogram with ggplot
ggplot(___)+
  geom_histogram(aes(x= ___), binwidth = __)
```

```{r q2b_plotdistances-hint-1}
# use the output from exercise 1b as the input for ggplot
```

```{r q2b_plotdistances-hint-2}
# plot the distance on the x axis
```

```{r q2b_plotdistances-hint-3}
# ie 
ggplot(dist_h3k4me3_to_tss)+
  geom_histogram(aes(x=dist.to.feature))
```

```{r q2b_plotdistances-hint-4}
# try binwidths of 10kb or 100kb, for example:
ggplot(dist_h3k4me3_to_tss)+
  geom_histogram(aes(x=dist.to.feature), binwidth = 1000)
```

```{r q2b_plotdistances_mc}
question("Which of the following statments are correct?",
         answer("Over 50% of the datapoints fall within 10kb up- or downstream the TSS", correct = T, message = "Indeed, over 50% of H3K4me3 peaks are within +/- 10kb of the TSS. But also notice the  outliers we are having: peaks are assigned to TSSs that are over 100kb away! These might be peaks in enhancers that are due to cross-reactivity of the antibody or chromosomal looping."),
         answer("Less than 50% of the datapoints fall within 10kb up- or downstream the TSS", message= "Review the output of question 2a. Take a carefull look at the 1st and 3rd Quartile values."),
         answer("A binwidth of 100kb, givs us the nicest histogram with sufficient detail but not too peaky.", message = "Try again, 100kb is a bit too large in this case."),
         answer("A binwidth of 10kb, givs us the nicest histogram with sufficient detail but not too peaky.", correct=TRUE),
         allow_retry=TRUE
         )
```

## 3.3 ChIP-seq signal strength     
Distance and overlap may tell you which gene and/or regulatory element the mark is most likely associated with. As we for example observed in fg2: the presence and absence of H3K4me3 and H3K27me3 at a gene's promoter is associated with gene expression. But there is more to it!  
<br>
Not only the presence or absence but the actual signal from ChIP-seq marks can be associated with the expression level of the gene in question. Such associations between ChIP-seq signal strength and gene expression - being it positive or negative associations - point to a functional relationship. Think of the ChIP-seq mark recruiting basal transcription factors or the deposition of marks by proteins recruited by the transcriptional machinery in elongation mode.  
<br>
In both cases you will observe a positive association between ChIP-seq signal strength and gene expression. In research, such observations (or the absence thereof) can help you decide on the direction and design of follow-up experiments.   
<br>
These relationships between signal intensity and gene expression may have already been discussed in your Epigenomics lectures. Let's look at how they look in real data.   

### 3.3.1 Importing ChIP-seq signal strength in r   
The ChIP-seq signal can be obtained from the data stored in .bam files or from .bigwig files. Remember from week 1, .bam files contain records of read alignments with 1 line per read. The .bigwig files do not store individual reads but the coverage across the genome, often normalized per million mapped reads.   
<br>
Not all packages and functions are compatible with both file types and the resulting plots may look differ in resolution in part because .bam files - as they store read information -  give you more freedom to define how coverage is calculated. However, as BLUEPRINT only provides the .bigwig files we will use those today and not the .bam files.   
<!-- REF: https://www.bioconductor.org/packages/release/bioc/vignettes/genomation/inst/doc/GenomationManual.html#4_Extraction_and_visualization_of_genomic_data   -->
<br>
We limited the data stored in the bigWig files to a **15kb window around the TSSs of 40% of genes (randomly selected) on chromosome 19**. This was done to reduce the size of these files (bigWig and .bam files are huge!) and speed up the tutorial a bit. We have made sure that this random selection still reflects the genome-wide relationships. However, because of this decision you can't make plots of other or wider windows than 15kb.   

### Exercise 3  
You will plot the average H3K4me3 ChIP-seq signal strength around the TSSS.  

A trick that prevents loading complete bigWig files in your environment is to load only the the regions of interest; in this case the window around the TSS. You load the signal in a "ScoreMatrix" object with the `ScoreMatrix()` function from the genomation package:  

```{r scorematrixcode, eval=FALSE, echo=TRUE}
ScoreMatrix(target = [path to bigwig file], 
            windows = [GRanges object with intervals of interest], 
            type = "bigWig", 
            strand.aware = [TRUE/FALSE])
```

* To take the strand of the TSS into account, we set `strand.aware=TRUE`.   
* Every row in the resulting ScoreMatrix object corresponds to a window of the `[regions of interest]`.  
* Every column in the resulting ScoreMatrix object is a bp within that window (see the image below).   

  ![ScoreMatrix visual](images/genomation_scorematrix.png){width=50%}\   
  *Modified from [GenomationManual](https://www.bioconductor.org/packages/release/bioc/vignettes/genomation/inst/doc/GenomationManual.html#1_Introduction): Wikipedia, Gene Structure*

<br>   
The GRanges object `tss_chr19_sample` contains the TSSs (1bp) of which we also have data in the bigwig files. The window is currently 1bp but we want to plot the signal *around* the TSS. To do so, we resize these 1bp intervals with the `resize()` function from the GenomicRanges package:  

```{r resizexcode, eval=FALSE, echo=TRUE}
resize(x = [GRanges object], width = [desired width], fix = ["start", "end" or "center"])
```

* If we want a window of 20kb around the TSS, use `width = 200001` to include the TSS (1bp extra).  
* As we want to have a window *around* the TSS we set the `fix = "center"`.  

> **Exercise 3a**: Run the code below to obtain the H3K4me3 signal in a 10kb window around the TSSs.  
>
> * The object `bw_h3k4me3` directs to the H3K4me3 ChIP-seq BigWig file.  
> * Hit "Run Code" to view the structure of the resulting ScoreMatrix object.   

```{r q3a_h3k4me3_scores, exercise=TRUE, exercise.eval=FALSE, error=TRUE}
# define the window size  
window <- 10001

# resize the tss interval to this window.
tss_window <- resize(tss_chr19_sample, width = window, fix = "center")

# create H3K4me3 ScoreMatrix for these intervals.
# strand.aware=TRUE takes into account the strand of the TSS. 
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', strand.aware =TRUE)  

# what structure is scores_h3k4me3? Hit "Run code" to view the result. 
str(scores_h3k4me3_tss)
```

The object `scores_h3k4me3_tss` is of formal class ScoreMatrix, which is related to a basic matrix but - as it says - "more formal". In other words, it has special functions to retrieve and set the data. We won't go into the details of these differences with basic matrices but focus on how we can use this result.  

### 3.3.2 Plot the average H3K4me3 signal around the TSS   
Using this ScoreMatrix you can plot the average H3K4me3 signal in these windows. To do so, use the `plotMeta()` function:   

```{r plotmeta_example, eval=FALSE, echo=TRUE}
plotMeta(mat = [ScoreMatrix_object], xcoord = c([start,end]))
```  

* Use the `xcoord =` parameter to define relative base positions for the x-axis and set the TSS at base '0'.  

<br>

> **Exercise 3b**: Plot the H3K4me3 signal stored in "scores_h3k4me3_tss" from exercise 3a (code check).   
>
> * Hit "Subit Answer" to submit your code.  
> * Hit "Run Code" to view the plot (necessary for exercise 3c).   

```{r prepare_q3b}
tss_window <- resize(tss_chr19_sample, width = 10001, fix = "center")
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', strand.aware =TRUE) 
```


```{r q3b_h3k4me3plot, exercise =TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup = "prepare_q3b"}
# plot of ScoreMatrix "scores_h3k4me3_tss"
___(mat = ___, xcoord = c(-5000, 5000))
```

```{r q3b_h3k4me3plot-solution}
plotMeta(mat = scores_h3k4me3_tss, xcoord = c(-5000, 5000))
```

```{r q3b_h3k4me3plot-code-check}
grade_code()
```

Clearly, we could have restricted the plot tp the region +/- 3kb the TSS as the H3K4me3 signal remains near 0 read per million outside that region.   

>**Exercise 3c**: Use the plot above to answer the following questions.    

```{r q3c_mc_densityplot}
quiz(caption="",
  question("Which function would you change and how, to make sure that the signal is limited to +/-3kb around the TSSs in the plot?",
         answer("Change the xcoord parameter in 'plotMeta', set it to c(-3000, 3000).", message = "Changing the xcoord parameter only changes the thickmarks on the x-axis but does not change the actual window size of the interval."),
         answer("Filter the ScoreMatrix 'scores_h3k4me3_tss' for columns c(-3000, 3000).", message = "We could filter the matrix indeed but these are not the correct columns as there are no 'negative' columns."),
         answer("Change the width parameter in 'resize', set it to 6001.", correct = T),
         allow_retry = T,
         random_answer_order = T), 
     question("Is H3K4me3 signal equally strong before and after the TSS or is there a difference?",
              answer("H3K4me3 signal appears equal up- and downstream the TSS.", message = "Look at the plot, the y-axis gives the H3K4me3 signal, the TSS is located at x=0."),
              answer("H3K4me3 signal is lower downstream the TSS compared to upstream.", message = "Review what is 'upstream' and what is 'downstream'."),
              answer("H3K4me3 signal is higher downstream the TSS", correct = T, message = "Indeed, H3K4me3 signal is on average higher downstream the TSS."),
              allow_retry = T),
     # question("What would the plot show, in case you would have set 'strand.aware=FALSE' in the 'ScoreMatrix()' function? Tip: You can adjust the code from 3a and 3b and try it.",
     #          answer("H3K4me3 signal appearing equal up- and downstream the TSS", correct = T, message = "As TSS are randomly distributed over strands, setting strand.aware to FALSE will lead to a plot where H3K4me3 signal appears equally strong before and after the TSS while in reality it is stronger downstream the TSS."),
     #          answer("H3K4me3 signal would appear lower downstream the TSS compared to upstream.", message = "Realize that randomly distributed over strands while the H3K4me3 signal around the TSS is related to the directionality."),
     #          answer("H3K4me3 signal would appear higher downstream the TSS", message = "Realize that randomly distributed over strands while the H3K4me3 signal around the TSS is related to the directionality."),
     #          allow_retry = T),
     question("What could explain the slight decrease in signal at pos. 0?", 
              answer("The nucleosome depleted region found at the TSS of transcribed genes.", correct = T),
              answer("The binding of specific TFs at the TSS."),
              answer("The TSS itself is marked by H3K4ac instaed of H3K4me3"),
              allow_retry = T)
)
```

### 3.3.3 Add H3K27ac signal   
Let's look at another promoter mark: does H3K27ac show the same shape and signal strength?  

### Exercise 4   

> **Exercise 4**: Generate a plot of the average H3K27ac signal in a **10kb** window around the TSS.  
> 
> * The object `tss_window` of exercise 3a has been loaded for you.  
> * The object `bw_h3k27ac` directs to the H3K27ac ChIP-seq BigWig file.  

```{r prepare_q4, echo=FALSE}
# resize the tss interval to this 10kb+1bpTSS
tss_window <- resize(tss_chr19_sample, width = 10001, fix = "center")
```

```{r q4_h3k27ac_density, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q4"}
# Create H3K27ac ScoreMatrix for the 10kb TSS windows.
scores_h3k27ac_tss <- ScoreMatrix(target = ___,
                                   windows = ___, 
                                   type = 'bigWig', strand.aware =TRUE)  

# Generate the plot with average H3K27ac scores 
___(___, xcoord = c(-5000, 5000))
```

```{r q4_h3k27ac_density-hint-1}
# "target =" should direct to the bigwig file. 
```

```{r q4_h3k27ac_density-hint-2}
# Eg 
ScoreMatrix(target = bw_h3k27ac, .....)  
```

```{r q4_h3k27ac_density-hint-3}
# And the "windows =" to the GRanges object with the intervals
```

```{r q4_h3k27ac_density-hint-4}
# Eg 
ScoreMatrix(target = bw_h3k27ac, windows = tss_window, ....)  
```

```{r q4_h3k27ac_density-hint-5}
# You can copy-paste and adjust the plotMeta() function from exercise 3b to make the plot. 
```

```{r q4_h3k27ac_density-hint-6}
# Warning: the next hint holds the solution!
```

```{r q4_h3k27ac_density-solution}
# create H3K27ac ScoreMatrix for the 10kb TSS windows.
scores_h3k27ac_tss <- ScoreMatrix(target = bw_h3k27ac, windows = tss_window, type = 'bigWig', strand.aware =TRUE)  

# Generate the plot with average H3K27ac scores t
plotMeta(scores_h3k27ac_tss, xcoord = c(-5000, 5000))
```

```{r q4_h3k27ac_density_mc}
question("Compared to the average score profile of H3K4me3, the H3K27ac profile ... (Select the correct statments)",
         answer("shows, on average, stronger signal scrores around the TSS.", message = "The signal scores are plotted on the y-axis of the plot. Compare the values in plot from ex 3 with t he latest plot."),
         answer("shows, on average, weaker signal scrores around the TSS.", correct = T, message = "To compare two profiles, you can plot them in one plot. Let's do that!"),
         answer("shows, on average, a wider region of enrichment around the TSS.", message = "Based on these two plots, the H3K27ac is not clearly wider on average than H3K4me3."),
         answer("shows, on average, a more narrow region of enrichment around the TSS.", message = "Based on these two plots, the H3K27ac is not clearly narrower on average than H3K4me3."),
         allow_retry=TRUE,
         random_answer_order=TRUE
         )
```

### 3.3.4 Multiple density profiles in one plot  
We can observe  differences and comparable trends better when we combine plots of the two marks. This is done by generating a "ScoreMatrixList" object and providing that to the `plotMeta()` function:    

```{r example_scorematrixlist, echo=TRUE, eval=FALSE}
# 1. Generate a "ScoreMatrixList" object:   
ScoreMatrixList_object <- new("ScoreMatrixList", 
                              list([object1_name]=[ScoreMatrix_1], ..., [objectN_name]=[ScoreMatrix_N]))

# 2. Provide plotMeta with this "ScoreMatrixList":   
plotMeta(mat = ScoreMatrixList_object, 
         xcoord = c([start,end]),
         overlay = [TRUE/FALSE], 
         profile.names = [vector of custom names, used for the legend])
```

* With `overlay=TRUE` the two density profiles are plotted in one plot.   
* With `overlay=FALSE` the two density profiles are plotted in separate plots with the same x- and y-axis limits and scales.  
* In `profile.names =` you can give a character vector of names, for every ScoreMatrix in the ScoreMatrixList.  

### Exercise 5  

> **Exercise 5**: Complete the code below to generate one plot with the density profiles of H3K4me3 and H3K27ac in a 10kb window around the TSS.  
> 
> * The objects `scores_h3k4me3_tss` and `scores_h3k27ac_tss` of exercise 3 and 4 are available to you.   
> * Hit "Submit Answer" to evaluate your code.  
> * Hit "Run Code" to view the plot.  

```{r prepare_q5, echo=FALSE}
tss_window <- resize(tss_chr19_sample, width = 10001, fix = "center")
# scores for h3k4me3
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', strand.aware =TRUE) 

# scores for h3k27me3 
scores_h3k27ac_tss <- ScoreMatrix(target = bw_h3k27ac, windows = tss_window, type = 'bigWig', strand.aware =TRUE)  
```

```{r q5_overlay, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q5"}
# generate a ScoreMartixList of "scores_h3k4me3_tss" and "scores_h3k27ac_tss" 
# (of exercise 3 and 4)
scores_h3k4me3_h3k27ac <- new("ScoreMatrixList", list(h3k4me3=___, h3k27ac=___))

# generate the plotMeta with overlay
plotMeta(mat = ___, xcoord = c(-5000, 5000), 
        overlay = ___, profile.names = c("H3K4me3", "H3K27me3"))
```

```{r q5_overlay-solution}
scores_h3k4me3_h3k27ac <- new("ScoreMatrixList", list(h3k4me3=scores_h3k4me3_tss, h3k27ac=scores_h3k27ac_tss))

plotMeta(scores_h3k4me3_h3k27ac, xcoord = c(-5000, 5000), overlay = TRUE, profile.names = c("H3K4me3", "H3K27ac"))
```

```{r q5_overlay-code-check}
grade_code()
```

Now we clearly see the differences in signal strengths between H3K4me3 and H3K27ac at the TSS!   
<br>
So far you have examined the average enrichment of "narrowPeak" ChIP marks. Let's add a mark with a different enrichment profile: **H3K27me3**.  

### 3.3.5 Add H3K27me3 signal    
You will add the H3K37me3 profile to the above plot.    

> **Exercise 6**: Generate a ScoreMatrix object with the H3K37me3 signal in a 10kb window around the TSS, make a new ScoreMatrixList with scores of H3K4me3, H3K27ac and H3K27me3 and plot these three profiles with plotMeta().  
> 
> * The object `bw_h3k27me3` holds the location of the H3K27me3 bigwig file.   
> * The object `tss_window` of exercise 3a is available too.  
> * The scores of H3K4me3 and H3K27ac are available in resp. `scores_h3k4me3_tss` and `scores_h3k27ac_tss`.  

```{r prepare_6a, echo=FALSE}
tss_window <- resize(tss_chr19_sample, width = 10001, fix = "center")

# scores for h3k4me3
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', strand.aware =TRUE) 

# scores for h3k27ac  
scores_h3k27ac_tss <- ScoreMatrix(target = bw_h3k27ac, windows = tss_window, type = 'bigWig', strand.aware =TRUE)
```


```{r q6a_addh3k37me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.lines=9, exercise.setup="prepare_6a"}
# 1. Create H3K27me3 ScoreMatrix for the 10kb windows around the TSS.
scores_h3k27me3_tss <- ScoreMatrix(target = ___, windows = ___, type = 'bigWig', strand.aware =TRUE)  

# 2. Create a new ScoreMatrixList object  
scores_h3k4me3_h3k27ac_h3k27me3 <- ____

# 3. Plot the average scores of these 3 marks with plotMeta()
# define overlay=TRUE 
# and fit the names in "profile.names=" with the order of objects in the ScoreMatrixlist object
plotMeta(____))
````

```{r q6a_addh3k37me3-hint-1}
# Look at exercises 3 and 4 to help you with the ScoreMatrix() function
```

```{r q6a_addh3k37me3-hint-2}
# Look at exercise 5 if you do not know how to create the ScoreMatrixList object
```

```{r q6a_addh3k37me3-hint-3}
# Look at exercise 5 if you do not know how to plot the ScoreMatrixList object
```

```{r q6a_addh3k37me3-hint-4}
# Start step 2 with
scores_h3k4me3_h3k27ac_h3k27me3 <- new("ScoreMatrixList", list(h3k4me3=scores_h3k4me3_tss, .... ))
```

```{r q6a_addh3k37me3-hint-5}
# Complete step 2:
scores_h3k4me3_h3k27ac_h3k27me3 <- new("ScoreMatrixList", list(h3k4me3=scores_h3k4me3_tss, h3k27ac=scores_h3k27ac_tss, h3k27me3=scores_h3k27me3_tss))
```

```{r q6a_addh3k37me3-hint-6}
# Start step 3 with
plotMeta(scores_h3k4me3_h3k27ac_h3k27me3, xcoord = c(-5000, 5000), overlay = TRUE, profile.names = .....)
```

```{r q6a_addh3k37me3-hint-7}
# The next hint contains a possible solution!
```

```{r q6a_addh3k37me3-solution}
# Create H3K27me3 ScoreMatrix for the 10kb windows around the TSS.
scores_h3k27me3_tss <- ScoreMatrix(target = bw_h3k27me3, windows = tss_window, type = 'bigWig', strand.aware =TRUE)  

# Create a new ScoreMatrixList object  
scores_h3k4me3_h3k27ac_h3k27me3 <- new("ScoreMatrixList", list(h3k4me3=scores_h3k4me3_tss, h3k27ac=scores_h3k27ac_tss, h3k27me3=scores_h3k27me3_tss))

# Plot the average scores of these 3 marks with plotMeta()
plotMeta(scores_h3k4me3_h3k27ac_h3k27me3, xcoord = c(-5000, 5000), overlay = TRUE, profile.names = c("H3K4me3", "H3K27ac", "H3K27me3"))
```

```{r q6a_addh3k37me3_mc}
question("What can you conclude from the above plot?",
         answer("On average H3K27me3 scores in these windows are lower than H3K27ac scores.", correct = T),
         answer("H3K4me3 scores are always higher than the H3K27ac scores.", message = "These plots display the *average* scores, there might still be TSS whith only H3K27ac or with a H3K27ac signal that is higher than H3K4me3, you can't say that from this plot."),
         answer("There are more TSSs overlapping a H3K4me3 peak than TSSs overlapping a H3K27ac peak.", message = "This plot does not display how many TSS overlap with a ChIP peak."),
         answer("There are no H3K27me3 peaks overlapping TSSs used to make this plot.", message = "The H3K27me3 signal is generally broad, spanning 10s of kbs and does not reach such high scores as H3k4me3. Using this plot, we can't concusively say that H3K27me3 is absent from these promoters."),
         allow_retry=TRUE,
         random_answer_order=TRUE
         )
```

These plots show the *average* ChIP-seq signal around the TSS. What they do not show is which peaks overlap and at which TSS they overlap. Neither do they reveal the range of score profiles. I.e. *"Do 90 or 50 or perhaps only 25% of H3K4me3 peaks follow this shape while the rest shows higher or lower enrichment scores?" "And if these profiles are not the same for each gene, might there be an association with gene expression levels?" "For which marks can we observe such an association and for which not?"*    

## 3.4 Signal vs gene expression  
You will investigate the the relationship between H3K4me3 signal (as reads per million extracted from the BigWig file) in a defined window around the TSS and gene expression (as FPKM). 

### 3.4.1 Average H3K4me3 signal per gene expression quartile  
To investigate this relationship you will:  

a. Calculate the average H3K4me3 signal in a 5kb window around the TSS.  
b. Convert the output of (a) in to a data.frame.  
c. Combine the data.frame with H3K4me3 scores with those containing gene expression values for the corresponding genes.    
d. Group genes based on their gene expression in 4 quartiles and plot the H3K4me3 signal per group in a boxplot.  

### Exercise 7a  
To calculate the average H3K4me3 signal in a defined window around the TSS you can use a modified version of the 'ScoreMatrix' function: 

```{r scorematrixbincode, eval=FALSE, echo=TRUE}
ScoreMatrixBin(target = [path to bigwig file], 
               windows = [GRanges object with intervals of interest], 
               bin.num = n,
               type = "bigWig", 
               strand.aware = [TRUE/FALSE])
```
As the name suggests, this function does not calculate the coverage for each bp in the given windows, but it will chop the intervals into `n` number of **bins**. The number of bins can be set with the `bin.num=` parameter. Setting this to  `bin.num=1`, will give the average signal for each window.   
<br>
Note that this function is also useful when working with windows of varying size like genes, in those cases we set `bin.num` to 50 or 100.  

> **Exercise 7a**: Calculate the average H3K4me3 signal in a window of 5kb around the TSS (code check).  
> 
> * `tss_chr19_sample` is the GRanges object with TSS locations for which we have signal in the BigWig files.  
> * Use `resize()` to resize the window in `tss_chr19_sample` to 5kb.  
> * `bw_h3k4me3` directs to the H3K4me3 ChIP-seq BigWig file.  

```{r q7a_signalfpkm, exercise=TRUE, exercise.eval=FALSE, error=TRUE}
# Re-size the window in "tss_chr_sample" to 5001bp
tss_chr19_sample_window <- resize(___, width = ___, fix = "center")

# Obtain the average H3K4me3 core for each window in "tss_chr19_sample_window"
average_h3k4me3_tss <- ScoreMatrixBin(target = bw_h3k4me3, 
                                             windows = ___, 
                                             bin.num = ___, 
                                             type = 'bigWig', strand.aware =TRUE)  
```

```{r q7a_signalfpkm-solution}
# Resize the window in "tss_chr_sample" to 5001bp
tss_chr19_sample_window <- resize(tss_chr19_sample, width = 5001, fix = "center")

# Obtain the average H3K4me3 core for each window in "tss_chr19_sample_window"
average_h3k4me3_tss <- ScoreMatrixBin(target = bw_h3k4me3, 
                                             windows = tss_chr19_sample_window, 
                                             bin.num = 1, 
                                             type = 'bigWig', strand.aware =TRUE)  
```

```{r q7a_signalfpkm-code-check}
#when I designed the tutorial, I saved this scorematrix object so that we do not need to rerun the function in coming questions but can directly load the output. 
#saveRDS(average_h3k4me3_tss, file = file.path("/home", "ctoenhake", "learnr.proto","inst", "extdata", "week3", "prepared_rds", "scorematrix_q6_average_scores_h3k4me3_tss_10kbwindow.rds"))

grade_code()
```

### Exercise 7b  
Next, transform the resulting 'ScoreMatrix' object to a data.frame to facilitate data manipulation with dplyr and plotting with ggplot2. You can transform:  

* a 'ScoreMatrix' into a basic matrix with: `matrix_object <- as([ScoreMatrix_object], "matrix")`  
* a matrix into data.frame with: `dataframe_object <- as.data.frame([matrix_object])`.    

> **Exercise 7b**: Transform the `average_h3k4me3_tss` to a data.frame.   

```{r q7b_prepare}
# scores from ex 5
average_h3k4me3_tss <- readRDS(file = system.file("extdata", "week3", "prepared_rds", "scorematrix_q5_average_scores_h3k4me3_tss_10kbwindow.rds", package = "learnr.proto"))
```

```{r q7b_signalvsfpkm, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="q7b_prepare"}
# transform average_h3k4me3_tss into a matrix
scores_as_matrix <- as(___, "matrix")

# and the matrix into a data.frame 
average_h3k4me3_tss_df <- as.data.frame(___)

# Print the head of the resulting data.frame  
# What is the name of the variable with the H3K4me3 scores?  
head(__)
```

```{r q7b_signalvsfpkm-solution}
# transform average_h3k4me3_tss into a matrix
scores_as_matrix <- as(average_h3k4me3_tss, "matrix")

# and the matrix into a data.frame 
average_h3k4me3_tss_df <- as.data.frame(scores_as_matrix)

# Print the head of the resulting data.frame  
# What is the name of the variable with the H3K4me3 scores?  
head(average_h3k4me3_tss_df)
```

```{r q7b_signalvsfpkm-check}
grade_result(
  pass_if(~identical(.result, head(as.data.frame(as(average_h3k4me3_tss, "matrix"))))),
  correct = "V1 is not an informative variable name and we are lacking the corresponding geneID! In the code below we therefore renamed 'V1' and added the variable 'gene_id'."
)
```

<br>
In the code below we... 

* renamed `V1` to `H3K4me3_rpm` using `rename()` from dplyr (we use the `dplyr::rename` formulation because multiple packages are loaded with a `rename()` function, this way r knows we want the dplyr-rename variant.);  
* added the variable `gene_id` (obtained from the GRanges object we used in we used in the `ScoreMatrixBin()` function: `tss_chr19_smaple`).  

```{r rename_example, echo=TRUE, eval=FALSE}
average_h3k4me3_tss_df <- as.data.frame(as(average_h3k4me3_tss, "matrix")) %>% 
  dplyr::rename(H3K4me3_rpm = V1)
average_h3k4me3_tss_df$gene_id <- tss_chr19_sample$gene_id
```

We can now visualize the range of average H3K4me3 scores in this 5kb window by running: 
```{r h3k4me3_boxplot_example, echo=TRUE, eval=FALSE}
ggplot(average_h3k4me3_tss_df) + 
  geom_boxplot(mapping = aes(y = H3K4me3_rpm))+
  scale_x_discrete(labels=NULL)+
  theme_bw()
```

![](images/boxplot_average_h3k4me3_tss_5kbwindow.png){width=40%}\  
```{r h3k4me3_boxplot_example2, eval=FALSE, echo=FALSE, fig.width=3, fig.height=3.8}
# when I made the tutorial, I saved the figure. The code to make the boxplot is shonw below, it is not run but the image from this chunk is shown. 
average_h3k4me3_tss <- readRDS(file = system.file("extdata", "week3", "prepared_rds", "scorematrix_q6_average_scores_h3k4me3_tss_10kbwindow.rds", package = "learnr.proto"))
average_h3k4me3_tss_df <- as.data.frame(as(average_h3k4me3_tss, "matrix")) 
average_h3k4me3_tss_df <- average_h3k4me3_tss_df %>% dplyr::rename(H3K4me3_rpm = V1)
average_h3k4me3_tss_df$gene_id <- tss_chr19_sample$gene_id

ggplot(average_h3k4me3_tss_df) + 
  geom_boxplot(mapping = aes(y = H3K4me3_rpm))+
  scale_x_discrete(labels=NULL)+
  theme_bw()
ggsave(filename= "images/boxplot_average_h3k4me3_tss_5kbwindow.png")
```

To generate this boxplot for groups of genes grouped into four bins by gene expression level, we first combine thess H3K4me3 scores with the gene expression data into one data.frame.  

### Exercise 7c  
Join the data from `quantification_chr19_sample` and `average_h3k4me3_tss_df` to get a data.frame with gene expression values and the corresponding average H3K4me3 signal at the TSS.   

* `quantification_chr19_sample` contains contains the gene expression values for this dataset, filtered for the genes for which we have data in our bigwig files.  
* These data were downloaded from the [blueprint dataportal](http://dcc.blueprint-epigenome.eu/#/experiments/ERX157053).  

To join these two data.frames you can use the `left_join()` function from dplyr:   

```{r inner_joing , echo=TRUE, eval=FALSE}
left_join(x = [dataframe 1], y = [dataframe 2], by = [variable to join by])
```

* This function outputs a data.frame includes all rows in `x` and their matching values for variables in `y` when they match for the variable defined by `by=`.  
* Print the head of `quantification_chr19_sample` to identify a useful variable to use in `by=` (**Hit "Run Code"**):    

```{r q7_prep, exercise=TRUE, exercise.eval=FALSE, error=TRUE}
# print the head of quantification_chr19_sample
head(quantification_chr19_sample, n=3)
```

> **Exercise 6c**: Use the `left_join()` function to combine `average_h3k4me3_tss_df` and `quantification_chr19_sample` (code check). 
>
> * Join these two data.frames by the variable "gene_id". 
> * Because we enable code checking, you have to explicitly define `x = ` and `y=` parameters. 


```{r q7c_prepare}
# scores from ex 5
average_h3k4me3_tss <- readRDS(file = system.file("extdata", "week3", "prepared_rds", "scorematrix_q6_average_scores_h3k4me3_tss_10kbwindow.rds", package = "learnr.proto"))
average_h3k4me3_tss_df <- as.data.frame(as(average_h3k4me3_tss, "matrix")) 
average_h3k4me3_tss_df <- average_h3k4me3_tss_df %>% dplyr::rename(H3K4me3_rpm = V1)
average_h3k4me3_tss_df$gene_id <- tss_chr19_sample$gene_id
```

```{r q7c_signalfpkm, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="q7c_prepare", exercise.lines=6}
# Join "quantification_chr19_sample" and "average_h3k4me3_tss_df" by "gene_id"
expression_and_h3k4me3 <- ____

# Print the head of the resulting output

```

```{r q7c_signalfpkm-solution}
# Join "quantification_chr19_sample" and "average_h3k4me3_tss_df" by "gene_id"
expression_and_h3k4me3 <- right_join(x = quantification_chr19_sample, y = average_h3k4me3_tss_df, by = "gene_id")

# Print the head of the resulting output
head(expression_and_h3k4me3)
```

```{r q7c_signalfpkm-check}
grade_result(
  pass_if(~identical(.result, 
                   head(right_join(x = quantification_chr19_sample, y = average_h3k4me3_tss_df, by = "gene_id"))
                   ))
)
```


### Exercise 7d  
To investigate the relationship between H3K4me3 signal strengths and gene expression, you will plot the average H3K4me3 signal for genes grouped by quantiles of gene expression. You thus need to define a new categorical variable that groups genes into 4 bins of equal size. You can achieve that using `ntile()` from dplyr:  
```{r ntile_example, echo=TRUE, eval=FALSE}
ntile(x = [variable to rank] , n = [number of bins])
```
By running `ntile()` within `mutate()` you can define the new variable. For example, below we, categorize genes into either quantiles or quintiles based on their gene expression in `quantification_chr19`:   
```{r ntile_example2, echo=TRUE}
# quantiles and quintiles in 
quantification_chr19 %>% 
  mutate(group_in_quantiles = factor(ntile(x = FPKM , n = 4)),
         group_in_quintiles = factor(ntile(x = FPKM , n = 5))) %>% 
  slice_head(n = 3)
```
* *Tip*: instead of printing the output of `mutate()` to the console or assigning it to a new object, you can also pipe the output directly into ggplot2.   

> **Exercise 7d**: Plot the H3K4me3 signal (y-axis) for genes grouped by gene expression (FPKM) quantile (x-axis) in a boxplot using ggplot (code check).   

```{r q7d_prepare}
# import scores from ex 6a
average_h3k4me3_tss <- readRDS(file = system.file("extdata", "week3", "prepared_rds", "scorematrix_q6_average_scores_h3k4me3_tss_10kbwindow.rds", package = "learnr.proto"))
# convert to df and rename and add variables for signal and gene_id
average_h3k4me3_tss_df <- as.data.frame(as(average_h3k4me3_tss, "matrix")) 
average_h3k4me3_tss_df <- average_h3k4me3_tss_df %>% dplyr::rename(H3K4me3_rpm = V1)
average_h3k4me3_tss_df$gene_id <- tss_chr19_sample$gene_id
# join with gene expression
expression_and_h3k4me3 <- right_join(x = quantification_chr19_sample, y = average_h3k4me3_tss_df, by = "gene_id")
```

```{r q7d_signalfpkm, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="q7d_prepare"}
# Define a new variable with mutate and ntile that groups genes in quartiles by gene expression 
# pipe the output into your ggplot 
expression_and_h3k4me3 %>%  
  mutate(____ = factor(ntile(FPKM, n=___))) %>% 
  ggplot(.)+  
  geom_boxplot(mapping=aes(x = ____, y = ___))+ 
  theme_bw()
```

```{r q7d_signalfpkm-solution}
expression_and_h3k4me3 %>%  
  mutate(gene_group = factor(ntile(FPKM, n=4))) %>% 
  ggplot(.)+  
  geom_boxplot(mapping=aes(x = gene_group, y = H3K4me3_rpm))+ 
  theme_bw()
```

```{r q7d_signalfpkm-code-check}
grade_code()
```

```{r q7e_signalfpkm_mc}
quiz(caption = "", 
     question("Is there a positive, negative or no association between average H3K4me3 signal at the TSS and gene expression of the corresponding gene?",
              answer("Positive", correct = TRUE, message = "Indeed, the higher positioning of the boxplots for genes with higher expression levels (higher gene group number) indicates a positive association between thees two variables."),
              answer("Negative", message = "Gene groups with in a higher category are genes with higher reported expression levels."),
              answer("Neither positive or negative"),
              allow_retry=TRUE),
     question("What type of plot would help you investigate this association further?",
              answer("Histogram"),
              answer("Scatter plot", correct=TRUE, message = "Let's make this plot!"), 
              answer("Violin plot"),
              random_answer_order=TRUE,
              allow_retry=TRUE)
)
```

### Exercise 7e  

> **Exercise 7e**: Repeat the plot of exercise 7d but this time plot a scatter plot (code check).  
>
> * Plot H3K4me3_rpm on the x-axis.  
> * Plot log(FPKM+1) on the y-axis (because of the broad range of RNA-seq we log the FPKM values).  
> * The object `expression_and_h3k4me3` is available.  
> * You do not need to define categories as in 7d. 


```{r q7e_signalfpkm, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="q7d_prepare", exercise.lines=4}
# Make scatter plot of gene expression by H3K4me3_rpm 
ggplot(expression_and_h3k4me3, mapping=aes(x = ___, y = ___))+
   ___()+
  theme_bw()
```

```{r q7e_signalfpkm-solution}
ggplot(expression_and_h3k4me3, mapping=aes(x = H3K4me3_rpm, y = log(FPKM+1)))+  
  geom_point()+
 geom_smooth(method=lm, fill = "blue")+
  theme_bw()
```

```{r q7e_signalfpkm-code-check}
grade_code()
```

**Observe that the association is only a *trend* and not a 1-to-1 relationship!** Additional factors influence or are associated with gene expression levels including the presence of other marks but also the presence of TFs and post-transcriptional mechanisms. What would we observe when we looked at a mark associated with gene silencing?  

### 3.4.2 H3K27me3 signal vs. gene experession  

>**Exercise 8a**: Use the code from exercises 7a-7d to plot the average H3K7me3 signal in a 5kb window around the TSS for genes grouped in quantile of gene expression (code check).    
> 
> * `bw_h3k27me3` points to the H3K27me3 ChIP-seq BigWig file.  

```{r q8a_h3k27me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.lines=4}
# Resize the window in "tss_chr19_sample" to 5kb
tss_chr19_sample_window <- resize(tss_chr19_sample, width = ___, fix = ___)
```

```{r q8a_h3k27me3-solution}
# Resize the window in "tss_chr19_sample" to 5kb
tss_chr19_sample_window <- resize(tss_chr19_sample, width = 5001, fix = "center")
```

```{r q8a_h3k27me3-code-check}
grade_code()
```

```{r prepare_q8b}
tss_chr19_sample_window <- resize(tss_chr19_sample, width = 5001, fix = "center")
```

```{r q8b_h3k27me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q8b"}
# Obtain the average H3K27me3 core for each window in "tss_chr19_sample_window"
average_h3k27me3_tss <- ScoreMatrixBin(target = ___,
                                       windows = ___,
                                       bin.num = ___,
                                       type = '___', 
                                       strand.aware = ___)

```

```{r q8b_h3k27me3-solution}
average_h3k27me3_tss <- ScoreMatrixBin(target = bw_h3k27me3,
                                       windows = tss_chr19_sample_window,
                                       bin.num = 1,
                                       type = 'bigWig', 
                                       strand.aware =TRUE)
```

```{r q8b_h3k27me3-code-check}
grade_code()
```

```{r prepare_q8c}
tss_chr19_sample_window <- resize(tss_chr19_sample, width = 5001, fix = "center")
average_h3k27me3_tss <- ScoreMatrixBin(target = bw_h3k27me3,windows = tss_chr19_sample_window,bin.num = 1,type = 'bigWig',strand.aware =TRUE)
average_h3k27me3_tss_matrix <- as(average_h3k27me3_tss, "matrix")
average_h3k27me3_tss_df <- as.data.frame(average_h3k27me3_tss_matrix)
```
 

```{r q8c_h3k27me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q8c"}
# Convert the ScoreMatrix output to a data.frame 
average_h3k27me3_tss_matrix <- ___
average_h3k27me3_tss_df <- ___
```

```{r q8c_h3k27me3-solution}
average_h3k27me3_tss_matrix <- as(average_h3k27me3_tss, "matrix")
average_h3k27me3_tss_df <- as.data.frame(average_h3k27me3_tss_matrix)
```

```{r q8c_h3k27me3-code-check}
grade_code()
```

```{r q8d_h3k27me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q8c"}
# and immediately add a column with 'gene_id'
average_h3k27me3_tss_df$gene_id <- ____
# use dplyr::rename to rename 'V1' to 'h3k27me3_rpm'
average_h3k27me3_tss_df <- ____ %>% ____
```

```{r q8d_h3k27me3-solution}
average_h3k27me3_tss_df$gene_id <- tss_chr19_sample$gene_id
average_h3k27me3_tss_df <- average_h3k27me3_tss_df %>% dplyr::rename(h3k27me3_rpm = V1)
```

```{r q8d_h3k27me3-code-check}
grade_code()
```

```{r prepare_q8d}
tss_chr19_sample_window <- resize(tss_chr19_sample, width = 5001, fix = "center")
average_h3k27me3_tss <- ScoreMatrixBin(target = bw_h3k27me3,windows = tss_chr19_sample_window,bin.num = 1,type = 'bigWig',strand.aware =TRUE)
average_h3k27me3_tss_matrix <- as(average_h3k27me3_tss, "matrix")
average_h3k27me3_tss_df <- as.data.frame(average_h3k27me3_tss_matrix)
average_h3k27me3_tss_df$gene_id <- tss_chr19_sample$gene_id
average_h3k27me3_tss_df <- average_h3k27me3_tss_df %>% dplyr::rename(h3k27me3_rpm = V1)
expression_and_h3k27me3 <- right_join(x = quantification_chr19_sample, y = average_h3k27me3_tss_df, by = "gene_id")
```

```{r q8e_h3k27me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q8d"}
# join the gene expression values from 'quantification_chr19_sample' with the average H3K27me3 signals from 'average_h3k27me3_tss_df'
# tip: use right_join
expression_and_h3k27me3 <- right_join(x = ___, y = ___, by = ___)
```

```{r q8e_h3k27me3-solution}
expression_and_h3k27me3 <- right_join(x = quantification_chr19_sample, y = average_h3k27me3_tss_df, by = "gene_id")
```

```{r q8e_h3k27me3-code-check}
grade_code()
```

```{r q8f_h3k27me3, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q8d"}
# finally, plot the H3K27me3 signal (y-axis) per gene group where genes are divided in four quantiles of gene expression  
expression_and_h3k27me3 %>%  
  ___(gene_group = ____) %>% # remember to define this as factor!
  ___(.)+  
  ___(mapping=aes(x = ___, y = ___))+ 
  theme_bw()
```

```{r q8f_h3k27me3-check}
grade_result(
   pass_if(~identical(.result, 
                      expression_and_h3k27me3 %>% 
                        mutate(gene_group = factor(ntile(FPKM, n=4))) %>% 
                        ggplot(.)+
                        geom_boxplot(mapping=aes(x = gene_group, y = h3k27me3_rpm))+
                        theme_bw()
                      )),
   incorrect = "Copy pase and adjust the code of exercise 7d."
)
```

If we make a scatter plot of the same relation we get the following plot:  

![](images/scatterplot_logfpkm1_h3k27me3_tss_5kbwindow.png){width=70%}\  
```{r prepare_scatter, echo=FALSE, eval=FALSE, fig.height=4, fig.width=6}
# I used this chunk to prepare the plot in advance.  
# plot scatter
expression_and_h3k27me3 %>%  
  ggplot(., mapping=aes(y = log(FPKM+1), x = h3k27me3_rpm))+  
  geom_point()+ 
  theme_bw()
ggsave(filename= "images/scatterplot_logfpkm1_h3k27me3_tss_5kbwindow.png")
```

```{r h3k27me3_mc}
question("What does best desicribe the relationship between H3K27me3 and gene expression as log(FPKM+1)?",
         answer("The data show a linear relationship."),
         answer("The data show an inverse linear relationship.", ),
         answer("The data show a non-lienar relationship.", correct=TRUE, message = "Note that it ."),
         allow_retry=TRUE
         )
```


## 3.5 Heatmaps  
In profile plts.... 
In boxplots and scatters... 
What now ....

### 3.5.1 Heatmap of 1 mark unordered  
Summarize H3K4me3 ChIP-seq signal at all TSSs in a heatmap.  
```{r example_densityplot, exercise =TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup = "prepare_q5"}
# plot density plot
plotMeta(scores_h3k4me3_tss, xcoord = c(-5000, 5000))

# plot heatmap
heatMatrix(scores_h3k4me3_tss, xcoord = c(-5000, 5000), order = T)
multiHeatMatrix(scores_h3k4me3_h3k27ac_h3k27me3, xcoord = c(-5000, 5000), order = T)

# multimatrix, cluster 
#multiHeatMatrix(scores_h3k4me3_h3k27ac_h3k27me3, xcoord = c(-5000, 5000), order = T, clustfun = function(x) kmeans(x, centers = 4)$cluster, col = list(wit-rood,wit-groen,wit-paars) )


```


```{r heatmap, eval =F}
# k-means clustering
cl1 <- function(x) kmeans(x, centers=3)$cluster
set.seed(1000)
heatMatrix(mat=scores_h3k4me3_tss_all,legend.name="tpm",winsorize=c(0,99),xlab="region around TSS",
         xcoords=c(-5000:4999),clustfun=cl1,
         cex.legend=0.8,main="H3K4me3 signal on promoters",cex.lab=1,
         cex.axis=0.9,grid=FALSE,
         user.order=c(1,3,2))

# hierarchical clustering
cl2 <- function(x) cutree(hclust(dist(x), method="complete"), k=3)
set.seed(1000)
heatMatrix(mat=scores_h3k4me3_tss_all,legend.name="tpm",winsorize=c(0,99),xlab="region around TSS",
         xcoords=c(-5000:4999),clustfun=cl2,
         cex.legend=0.8,main="H3K4me3 signal on promoters",cex.lab=1,
         cex.axis=0.9,grid=FALSE)
```

```{r making correlation, eval = F}
h3K4me3_and_rnaquant <- merge(scores_as_df, quantification_chr19, by.x = "gene_id", by.y = "entrezgene_id")
h3K4me3_and_rnaquant %>%
  mutate(expression_group = ntile(FPKM, 4)) %>%
  ggplot(.)+
  geom_boxplot(mapping=aes(x = as.factor(expression_group), y = V1))


scores_h3k4me3_tss_10kb <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window, type = 'bigWig',strand.aware =TRUE)
scores_as_df_10kb <- as.data.frame(tss_window$gene_id)
colnames(scores_as_df_10kb) <- "gene_id"
scores_as_df_10kb$mean_h3k4me3 <- apply(as(scores_h3k4me3_tss_10kb, "matrix"), 1, mean)
scores_as_df_10kb$sum_h3k4me3 <- apply(as(scores_h3k4me3_tss_10kb, "matrix"), 1, sum)
scores10kb_and_quant <- merge(scores_as_df_10kb, quantification_chr19, by.x = "gene_id", by.y = "entrezgene_id")
cor(log10(scores10kb_and_quant$FPKM+1), scores10kb_and_quant$sum_h3k4me3)
cor(log10(scores10kb_and_quant$FPKM+1), scores10kb_and_quant$mean_h3k4me3)

head(scores_as_df_10kb)
```



### 3.5.2 Ordering a heatmap  
By gene expression of corresponding gene  

### 3.5.3 Same order, other mark  
By k-means or hierarchical clustering. 
Perhaps add background info section on clustering (?)  

### 3.5.4 Heatmap of all available histone marks, cluster on patterns    
Heatmap of all marks at the TSSs.   

How do you define the clusters? Use ChromHMM. 

## 3.6 ChromHMM  
Back-analyze chromHmm output, in other words, heatmap summary of signal intensities of the different marks in chromHMM defined regions. Regions are labelled 1-12, can you, using the sig

Chromatin states - re-occurring, co-localization of histone marks and factors - mapping of epigenomic marks, such as histone modifications, histone variants, regions of open chromatin, and related marks, has emerged as a powerful means to annotate genomes, to identify putative regulatory elements, and to study their changing activity across different cell types and in human disease1,2,3,4. Individual marks can be studied in isolation, either through aggregation of their genome-wide signal tracks relative to a set of predetermined annotations5, such as transcription start sites or exon boundaries, or by discovery of narrow peaks or broader domains in which the mark is present in greater frequency than that of the surrounding regions6. However, additional information can be gained by studying combinations of multiple marks in their spatial context. Such patterns, termed 'chromatin states', often capture known classes of genomic elements, such as promoters, enhancers, and transcribed, repressed, and repetitive regions7, and can also capture novel classes or subclasses of elements. (https://www.nature.com/articles/nprot.2017.124)

State1.- Repressed Polycomb High signal H3K27me3 -A 
State2.- Repressed Polycomb Low signal H3K27me3 - A
state3.- Low signal
State4.- Heterochromatin High Signal H3K9me3 - B
State5.- Transcription High signal H3K36me3 - C 
State6.- Transcription Low signal H3K36me3 -C
State7.- Genic Enhancer High Signal H3K4me1 & H3K36me3
State8.- Enhancer High Signal H3K4me1
State9.- Active Enhancer High Signal H3K4me1 & H3K27Ac - D
State10.- Distal Active Promoter (2Kb) High Signal H3K4me3 & H3K27Ac & H3K4me1 - D
State11.- Active TSS High Signal H3K4me3 & H3K4me1 - E 
state12.- Active TSS High Signal H3K4me3 & H3K27Ac - E

### Exercise chromhmm    
```{r chromhmm, eval =FALSE}
#library(pheatmap)
library(RColorBrewer)
chromhmm_file <- system.file("extdata", "week3",  "C000S5H1_12_12_Blueprint_release_201608_dense_chr19.bed", package = "learnr.proto")
chromhmm <- rtracklayer::import(chromhmm_file)
# 12 states - which is what?  
table(chromhmm$name)  
chromhmm_list <- split(chromhmm, chromhmm$name,drop=TRUE)

mono_list <- GRangesList(monocytes_list, compress =FALSE)

chrommhmm_anno_list <- annotateWithFeatures(mono_list,chromhmm_list)
heatTargetAnnotation(chrommhmm_anno_list)+
  coord_flip()+
  scale_fill_gradient(low = "white", high = "blue")
  
mat=heatTargetAnnotation(chrommhmm_anno_list,plot=FALSE)



#pheatmap(mat = mat, 
#         color = c("white", brewer.pal("Reds", n =9)),
#         cluster_cols =FALSE)

      
#BiocManager::install("pheatmap")

```



