---
title: "Week 3: Using ChIP-seq signal intensities"
tutorial:      # where learnr stores the progress
  id: "FG3"    # folder name
  version: 0.1 # subfolder name
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: true
    allow_skip: true
    css: css/custom.css
runtime: shiny_prerendered
description: >
  Multi line text can be put here
  for your convenience.
---


```{r setup, include=FALSE}
library(learnr)     # 0.10.1.9006 (github)
library(gradethis)  # 0.1.0.9004  (github)
library(testthat)   # 3.0.0 
library(tidyverse)  # 1.3.0
library(learnr.proto)

library(IRanges)
library(GenomicRanges)
library(plyranges)
library(rtracklayer)
library(VennDiagram)
library(GenomicFeatures)
#library(ComplexHeatmap) # for upset plot with GRanges, may be unloaded for fg3
library(genomation)
library(ggthemes)
#library(org.Hs.eg.db)


# load the txdb package which holds transcript-based gene models of hg38 genome  
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene 
seqlevels(txdb) <- "chr21"

# configuration
knitr::opts_chunk$set(echo=FALSE, message=FALSE)
gradethis::gradethis_setup()

# data accessible to all exercises
# peaks in GRanges objects (limited to chr21) and quantification at gene level (limited to chr21)
# rdata = system.file("extdata", "week3.Rdata", package = "learnr.proto") # week3 contains chr21 peaks in GRanges objects (week2 worked on chr19)
load("/home/ctoenhake/learnr.proto/inst/extdata/week3.Rdata") # emergency solution because I couldn't get this file installed in learnr.proto library
monocytes_list <- GRangesList(monocytes_list, compress=FALSE)

# chr21_windows_1bp <- tileGenome(seqinfo(txdb), tilewidth = 10, cut.last.tile.in.chrom =TRUE)
tss_chr21 <- unique(promoters(genes(txdb), upstream=100, downstream=0)) 
tss_chr21  <- resize(tss_chr21, width = 1, fix = "end")
tss_chr21$name <- tss_chr21$gene_id
promoters_chr21 <- unique(promoters(genes(txdb), upstream=2000, downstream=200)) 
genes_chr21 <- unique(genes(txdb))
```

```{r timeout1, context="server"}
isolate({
  # obtain the session id
  # source 1: https://shiny.rstudio.com/reference/shiny/latest/session.html
  # source 2: https://stackoverflow.com/questions/18900955/get-environment-identifier-in-r
  session_id <- sub('<environment: (.*)>', '\\1', capture.output(session$userData))
  
  # # send the session ID to the log (indicates the tutorial is loaded)
  # write(paste0("Session ID: ", session_id), stderr())
  
  # send the session ID to the javascript chunk
  session$sendCustomMessage("session_id", session_id)
})

# stop the tutorial when "input[[session_id]]" is updated
observeEvent(input[[session_id]], ignoreNULL=TRUE, {
  write(paste0("\nTutorial terminated due to inactivity.\nRestart to continue where you left off!\n"), stderr())
  stopApp()
})
```

```{js timeout2}
// This chunk stops the tutorial if it has been idle for too long

// Situation: We need to stop inactive tutorials to prevent the server from grinding to a halt.
// Problem: refreshing the tutorial and closing the browser send the same signal to shiny.
// since we cannot distinguish the two, this signal cannot be used to stop the tutorial.
// Solution: Use a timeout system. 
// Method: this chunk will update shiny variable "input[[session_id]]" 
//   when the session has been running idle for longer than "timeoutSec" seconds.
// This signal is then be used by Shiny (server-side) to stop the session.

// source1: https://community.rstudio.com/t/keeping-track-of-idle-time-during-app-usage/1735
// source2: https://bookdown.org/yihui/rmarkdown/language-engines.html#javascript-and-css
$(function() {
  var timeoutSec = 15*60;
  var idleTimer;

  // receive this session's ID
  Shiny.addCustomMessageHandler("session_id", function(s_id) {
    session_id = s_id;  // assigns the variable globally
  });

  // assign session ID as reactive variable "input[[session_id]]" 
  function onTimeout() {
    alert("Tutorial stopped due to inactivity.\nRestart to continue where you left off!")
    Shiny.setInputValue(session_id, "TRUE");
  }

  function startIdleTimer() {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(onTimeout, timeoutSec * 1000);
  }
  
  $(document).on('shiny:message shiny:inputchanged', startIdleTimer);

})();
```

## 3.1 Introduction   
<br>
In week 2 we quantified and visualized the overlap between histone peaks and promoters and examined the association with gene expression. Although informative, we have been ignoring the ChIP-seq signal intensities altogether.  
<br>
This week you will investigate the relationship between histone PTMs and gene expression further by including ChIP-seq signal intensities in your analyses. You will generate plots displaying the distribution of ChIP-seq signal around certain genomic positions, here a set of promoter regions to answer common questions like: "*What is the signal of the mark around the TSS?*", "*What is the relationship between histone ChIP-seq signal intensity and gene expression?*". These plots include an average signal profile, also called density plot, and a heatmap representation. You could use dplyr-related functions and ggplot-ting to achieve this but it is much more convenient to use dedicated tools for these tasks. We have chosen for the [genomation](https://github.com/BIMSBbioinfo/genomation) package for this purpose because it is compatible with the file types that we have available. (Side note: there are a number of other packages to analyze ChIP-seq data we well. Incl. ChIPpeakAnno and ChIPseeker.)   
<br>
We have installed and loaded this package for you with the following code:  
```{r install_genomation, echo = T, eval =FALSE}
BiocManager::install("genomation")
library(genomation)
```

### Tutorial specs  
The exercises in this tutorial are similar to those in fg2. A brief reminder:  

- For some longer coding exercises, we left blanks as "___" that indicate where in the code you should fill in a function, object or variable. Make sure fill out all the blanks before Answer submission, they will otherwise result in errors.  
- Hit `Hint` (when provided) for clues.  
- Hit `Run Code` to test your code and preview the output.  
- Hit `Submit Answer` (if present) to submit the code. As 'submitting' not always shows the code output, we advise to use `Run Code` first. Upon hitting `Submit Answer` and when code-checking is enabled and your submitted code is different from the solution code, R will give automatic feedback that helps you correct your code.  
- Hit `Start Over` to remove any adjustments you made and start again.   
- Try to keep yourself from hitting `Solution` (when provided). This is option is sometimes provided when your code is evaluated. Only use it when you do not understand the automatic feedback given by R.   

Although we ask for specific answers or completion of specific code, you are encouraged to test your own code and use `Run Code` and `Start Over` extensively. I.e., remove the pre-coded code and write your own code for a different graph or different summary of the data. Use `Run Code` to preview the results. Unfortunately these self-thought of codes can not be evaluated. For the evaluation you need to use our pre-coded code. Hit `Start Over` to get this pre-coded code.  

### 3.1.1 Learning Objectives  

> At the end of week 3 you are able to:  
> 
1. Identify the nearest TSS to a histone ChIP-seq peak.  
3. Plot the distribution of distances to the TSS.      
2. Import coverage values stored in bigwig files in r.  
4. Plot the average histone ChIP-seq signal around a genomic feature like the TSS (= density plot).  
5. Plot the relationship between ChIP-seq signal at the TSS and gene expression.   
6. Optionally, test for significance of the observed association.  
7. Summarize ChIP-seq signal in a heatmap figure.  
8. Order the heatmap of (7) by gene expression.  
9. Cluster the heatmap of (7) based on ChIP-seq signals of different marks.  
10. Optionally, back-analyze chromHmm output, in other words, heatmap summary of signal intensities of the different marks in chromHMM defined regions. Regions are labelled 1-12, can you, using the sig
  
<!-- ### large domain H3K27me3   -->
<!-- - overlap met H3K4me1 -->
<!-- - welke genen zijn bivalent   -->

<!-- ## structure -->
<!-- 1.  -->
<!-- 2. gemiddelde H3K4me3 signaal rond TSS -->
<!-- 3. groepering naar genexpressielevel per quantile voor H3K4me3 -- shows relatie met gen expresssie -->
<!-- 4. Hoe zit dat bij H3K27me3 (niet bij heel hoge expressie, breed signaal, je pakt maar een stukje) -->
<!-- 5. Hoe zit dit er uit als we elk datapunt bekijken in dotplot/scatterplot -- shows geen 100% vertaling/relatie, waarneming hieruit het is een trend en geen harde waarheid komt (deels) door invloed van andere marks = combinatorial markings.  -->
<!-- 6. Heatmap van histone marks at TSS random. Dan geordend op genexpressie niveau.   -->

<!-- <br> -->

## 3.2 Identify nearby TSSs  
### 3.2.1 Identify the nearest TSS   
First, let's identify the nearest TSS and plot the distance between a histone mark and it's nearest TSS (in contrast to identifying strict overlap as in fg3). 

### Exercise 1  
Identify the nearest TSS for each H3K4me3 peak in monocytes.   

> **Exercise 1a**: Recap, which of the commands below imports the peaks table into a GRanges object?  

```{r qimport}
question("Which function imports the H3K4me3 peaks into a GRanges object?",
         answer("import(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr21.bed\", format = \"narrowPeak\")", correct =TRUE),
         answer("import(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr21.bed\", format = \"BED\")", message = "BED is not the right format."),
         answer("import(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr21.bed\", format = \"broadPeak\")", message = "check the file format."),
         answer("read.table(\"C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr21.bed\", format = \"broadPeak\")", message = "read.table parses the data into a data.frame while we asked for a GRanges object."),
         allow_retry =TRUE,
         random_answer_order =TRUE)
```

### Exercise 1b  
To identify the nearest TSS, you use the function:  
`distance2NearestFeature(g.idh = [GRanges object withe peaks], tss = [GRanges object with TSSs])`  

The output is a data.frame reporting for each range in the `g.idh` object:

- its nearest TSS  
- the name of the corresponding peak and TSS  
- the distance between them. 

The fact that the output is a data.frame makes it easy for us to summarize the results with dplyr and ggplot2.      

<!-- 1. target.row = index of the peak in the GRanges object with peaks.   -->
<!-- 2. dist.to.feature = distance to the nearest TSS, negative when the peak is *upstream* of the TSS.    -->
<!-- 3. feature.name = the Entrez gene id of the corresponding gene, given in the column "names" of object `tss_chr21`.    -->
<!-- 4. feature.strand = strand of the TSS.    -->

> **Exercise 1b**: Identify the nearest TSS for each H3K4me3 ChIP-seq peak.  
> 
- TSS locations are stored in object `tss_chr21`.  
- H3K4me3 peaks in monocytes are stored in `monocytes_h3k4me3`.   
- Print the head of the resulting object to the console using `head()`.     

```{r q1_distancetss, exercise =TRUE, exercise.lines = 5, exercise.eval =FALSE, error = T}
# Identify the nearest TSS for each H3K4me3 peak  
dist_h3k4me3_to_tss <- __(g.idh = __, tss = __)

# Show the resulting object 

```

```{r q1_distancetss-hint-1}
# use the function
distance2NearestFeature()
```

```{r q1_distancetss-hint-2}
# within distance2NearestFeature define g.idh as:
g.idh = monocytes_h3k4me3
```

```{r q1_distancetss-hint-3}
# and tss as:
tss = tss_chr21
```

```{r q1_distancetss-hint-4}
# finish with
head(dist_h3k4me3_to_tss)
```

```{r q1_distancetss-check}
grade_result(
  pass_if(~identical(.result, head(distance2NearestFeature(monocytes_h3k4me3, tss_chr21))))
)
```

The `dist_h3k4me3_to_tss` reports for each H3K4me3 peak a nearest TSS. In total `r length(unique(distance2NearestFeature(monocytes_h3k4me3, tss_chr21)$feature.name))` different TSSs are reported, meaning that some peaks are assigned to the same TSS. *Which variable reports the distance between the peak and its nearest TSS?*       
<br>

>#### **Optional check**:  
<details><summary>Curious to check the matches in the genome browser?:</summary>   
<br>
You may want to check some of the matches. For example to check that positive distances are indeed peaks that are located *downstream* the TSS. To do so...  
1. View a part of the output of `dist_h3k4me3_to_tss`. For example, peaks with `dist.to.feature` above 1kb, sorted by distance, showing only the top 5 of the output by running: `dist_h3k4me3_to_tss %>% filter(dist.to.feature >= 1000) %>% arrange(dist.to.feature) %>% slice_head(n=5)`   
2. The first row reports:     
  `r distance2NearestFeature(monocytes_h3k4me3, tss_chr21) %>% filter(dist.to.feature >= 1000) %>% arrange(dist.to.feature) %>% slice_head(n=2) %>% slice_tail(n=1)`  
3. You can either look up the gene id ('feature.name' variable) in the [ncbi gene database](https://www.ncbi.nlm.nih.gov/gene/) and use the gene symbol to navigate to the right location in the UCSC genome browser.  
3. Or subset `monocytes_h3k4me3` with the given index in the 'target.index' column (805): `monocytes_h3k4me3[805]`.  
4. Go to the UCSC Genome Browser.  
5. Upload the monocytes trackhub (same as fg1): `http://mbdata.science.ru.nl/ctoenhake/edu/trackhub_monocytes/hub.txt`.    
  + Go to the tab "My Data" in the top menu.  
  + Select "Track Hubs".   
  + In the "My hubs" tab you can paste the above URL.  
  + You need to change the visibility of the tracks with "monocyte_H3K4me3_peaks" from "hide" to "pack". This can be done below the browser view. Remember to hit `Refresh`.  
6. Navigate to the gene from step 3 or the genomic region of step 4.  
  + In this example: `chr21:11577771-11577970`.    
7. Zoom out and observe or measure the location of the peak in relation to the TSS of the gene given in step 3. The name of the peak is given in the output of step 4.   
8. This confirms that **positive dist.to.feature values indicate that the H3K4me3 peaks is located *downstream* the TSS**.  
</details>  

### 3.2.2 Visualize distances  
Having identified the nearest TSS for each H3K4me3 peak, we want to summarize the distances between H3K4me3 peaks and TSSs.  
<!-- We are only interested in matches between H3K4me3 peaks and nearby TSSs. But what is nearby? We will use the distribution of distances to set the cut-off.   -->
### Exercise 2  

> **Exercise 2a:** Print a summary of the distances reported in `dist_h3k4me3_to_tss` using the `summary()` function.
> 
> * Tip: Look at the output from exercise 1b to identify the variable that stores the distances.   

```{r prepare_q2a, echo =FALSE}
 dist_h3k4me3_to_tss <- distance2NearestFeature(monocytes_h3k4me3, tss_chr21)
```

```{r q2a_summary, exercise =TRUE, exercise.eval =FALSE, error = T, exercise.setup = "prepare_q2a"}
# print a summary of the distances

```

```{r q2a_summary-hint-1}
# We want a summary of 
dist_h3k4me3_to_tss$dist.to.feature
```

```{r q2a_summary-check}
grade_result(
  pass_if(~identical(.result,summary(dist_h3k4me3_to_tss$dist.to.feature)))
)
```

### Exercise 2b  

> **Exercise 2b:** Plot the distances from `dist_h3k4me3_to_tss` using ggplot() and geom_histogram() and answer the multiple-choice question below.     
>
> * With the summary of exercise 2a in mind, play around with the `binwidth  =` parameter in `geom_histogram()`. 

>#### **Refresher**: histograms   
<details><summary>Click here for a quick explainer on histograms and the importance of the bin width or bandwidth.</summary>   
**Histograms** visualize the distribution of a single variable. Events are grouped into bins with comparable values and the number of events per bin is counted and these counts are visualized.  
<br>
Because histograms are made by binning the data, the bin width is a critical parameter that will affect the appearance of the graph. Choosing a bin width that is too small will result in a overly busy and peaky histogram making it difficult to discern the main trends. If the bin width is too large, then smaller features of the distribution may dissapear.  
<br>
In practice, if you generate a histogram, always explore multiple bin widths besides the default settings.   
<br>
In geom_histogram(), the bin width can be set by:  
> 
- Specify the parameter "binwidth", eg `binwidth = 5`   
- Specify the parameter "breaks", eg `breaks=seq(20, 50, by=2)` or `breaks=c(0,100,200)`  
</details>  

```{r q2b_plotdistances, exercise =TRUE, exercise.eval =FALSE, error = T, exercise.setup = "prepare_q2a"}
# plot the distances as histogram with ggplot
ggplot(___)+
  geom_histogram(aes(x= ___), binwidth = __)
```

```{r q2b_plotdistances-hint-1}
# use the output from exercise 1b as the input for ggplot
```

```{r q2b_plotdistances-hint-2}
# plot the distance on the x axis
```

```{r q2b_plotdistances-hint-3}
# ie 
ggplot(dist_h3k4me3_to_tss)+
  geom_histogram(aes(x=dist.to.feature))
```

```{r q2b_plotdistances-hint-4}
# try binwidths of 10kb or 100kb, for example:
ggplot(dist_h3k4me3_to_tss)+
  geom_histogram(aes(x=dist.to.feature), binwidth = 1000)
```

```{r q2b_plotdistances_mc}
question("Which of the following statments are correct?",
         answer("Over 50% of the datapoints fall within 10kb up- or downstream the TSS", correct = T, message = "Indeed, over 50% of H3K4me3 peaks are within +/- 10kb of the TSS. But also notice the  outliers we are having: peaks are assigned to TSSs that are over 100kb away! These might be peaks in enhancers that are due to cross-reactivity of the antibody or chromosomal looping."),
         answer("Less than 50% of the datapoints fall within 10kb up- or downstream the TSS", message= "Review the output of question 2a. Take a carefull look at the 1st and 3rd Quartile values."),
         answer("A binwidth of 100kb, givs us the nicest histogram with sufficient detail but not too peaky.", message = "Try again, 100kb is a bit too large in this case."),
         answer("A binwidth of 10kb, givs us the nicest histogram with sufficient detail but not too peaky.", correct=TRUE),
         allow_retry=TRUE
         )
```

As we want to plot the ChIP signal around the TSS, we will select only TSS that are near a H3K4me3 peak and not distort our signal plot with TSS without a H3K4me3 peak nearby. As >50% of "distances" are within 10kb, we will filter for matches within that distance. 

### 3.2.3 Filter on distances  
In this exercise you will use the filter function from dplyr to filter `dist_h3k4me3_to_tss` for matches that are within +/-10kb distance.    

>#### **Refresher**: dplyr     
<details><summary>Click here for a short list of common dplyr-functions and logical operators used to filter our data.</summary>   
>
Function | Purpose | Example     
:--|:----       
`select()` | subset variables (=columns) | select TSS column: `dist_h3k4me3_to_tss %>% select(feature.name)`  
`group_by()` | group data into rows with the same value for the specified variable. | group by TSS: `dist_h3k4me3_to_tss %>% select(feature.name)`   
`filter()` | subset observations (= rows) | filter for TSSs on the "-" strand: `dist_h3k4me3_to_tss %>% filter(feature.strand == "-")`  
`summarize()` | Summarise variables, often per group | print the mean distance grouped by strand: `dist_h3k4me3_to_tss %>% group_by(feature.strand) %>% summarize(mean = mean(dist.to.feature))`  
`mutate()` | Add a new variable | Add column with absolute distances: `dist_h3k4me3_to_tss %>% mutate(abs_distance = abs(dist.to.feature))`
>
See also the [dplyr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-transformation.pdf)(use right mouse-click, and open in a new window.)    
>
Within `filter()` you can use the following logical operators:  
>
Operator | Effect  
:--|:---  
== | Equal to   
!= | Not equal to  
< | Less than  
<= | Less than or equal to
\> |  Greater than  
>= | Greater than or equal to  
</details>  

> **Exercise 3:** Filter `dist_h3k4me3_to_tss` for matches that are within +/-10kb distance.      

```{r q3_filter, exercise =TRUE, exercise.eval =FALSE, error = T, exercise.setup = "prepare_q2a"}
# filter dist_h3k4me3_to_tss for distances within 10kb 
dist_h3k4me3_to_tss <- dist_h3k4me3_to_tss %>% 
  filter(___)
```

```{r q3_filter-hint-1}
# You need to use two conditions in your `filter()` function, one to select all peaks that are upstream (negative distances) the TSS and one for peaks that are downstream (positive distances) the TSS. 
```

```{r q3_filter-hint-2}
# Combine the conditions with & 
```


```{r q3_filter-hint-3}
# Eg if we would select for peaks within 5kb upstream the TSS we would use:
filter(dist.to.feature >= -5000)  
```

```{r q3_filter-hint-4}
# Eg if we would select for peaks within 5kb downstream the TSS we would use:
filter(dist.to.feature <= 5000)  
```

```{r q3_filter-hint-5}
# And for peaks that are 5kb downstream or 5kb usptream the TSS we would use:
filter(dist.to.feature >= -5000 & dist.to.feature <= 5000 )  
```

```{r q3_filter-hint-6}
# Warning, the next hint contains the solution! 
```

```{r q3_filter-solution}
# filter dist_h3k4me3_to_tss for distances <= 10000
dist_h3k4me3_to_tss <- dist_h3k4me3_to_tss %>% 
  filter(dist.to.feature >= -10000 & dist.to.feature <= 10000)
```

```{r q3_filter-code-check}
grade_code()
```

Having filtered `dist_h3k4me3_to_tss` you will continue to plot the H3K4me3 signal around these TSSs.    

## 3.3 Visualize signal intensity   
The TSS with a 'nearby H3K4me3' peak can be obtained from `dist_h3k4me3_to_tss$feature.name`. This gives the Entrez gene ID which we can use to filter our `tss_chr21` object  

### 3.3.1 ChIP-seq signal intensity   
The ChIP-seq signal can be obtained from the data stored in .bam files or from .bigwig files. Remember from week 1, .bam files contain records of read alignments with 1 line per read. The .bigwig files do not store individual reads but the coverage across the genome, often normalized per million mapped reads.   
<br>
Not all packages and functions are compatible with both file types and the resulting plots may look differ in resolution in part because .bam files - as they store read information -  give you more freedom to define how coverage is calculated. However, as BLUEPRINT only provides the .bigwig files we will use those today and not the .bam files.   
<!-- REF: https://www.bioconductor.org/packages/release/bioc/vignettes/genomation/inst/doc/GenomationManual.html#4_Extraction_and_visualization_of_genomic_data   -->

### 3.3.2 Store signal intensity in a matrix  
You will plot the H3K4me3 ChIP-seq signal intensity around TSSs in a density plot, averaged for all TSSs with a H3K4me3 peak (the ones selected above).  

>#### **Background info**: Density plots  
<details><summary>What is a density plot?</summary>   
**Density plots** visualize the estimated, underlying probability distribution by drawing an appropriate continous curve. The most commonly used method for to estimate this curve is called the *kernel density estimation*. In kernel density estimation, we draw a continuous curve (the kernel) with a small width (controlled by a parameter called bandwidth) at the location of each data point, and then we add up all these curves to obtain the final density estimate.  
<br>
Just as is the case with histograms, the exact visual appearance of a density plot depends on the kernel and bandwidth choices. The bandwidth is related to the binwidth in histograms. The choice of kernel affects the shape of the density curve (eg. gaussian like for Gaussian kernel but stepwise with a rectangular kernel).  
<br>
In general, the more data points there are in the data set, the less the choice of the kernel matters. Therefore, density plots tend to be quite reliable and informative for large data sets but can be misleading for data sets of only a few points.
<br>
Density curvuse are usually scaled such that the area under the curve equals 1.  
<br>
Kernel density estimates have one major pitfall: they have the tendency to extrapolate the curve towards regions that are non-existing (eg. into negative age when one plots a kernal density distribution of ages within a country).   
<br>
See for a more extended discussion on histograms and density plots Chapter 7 of Fundamentals of Data Visualization by Claus O. Wilke [ref](https://clauswilke.com/dataviz/histograms-density-plots.html).  
</details>  

A trick that prevents loading complete bigWig files in your environment is to load only the the regions of interest; in this a window around the TSS. You load the signal in a "ScoreMatrix" object using the following function from the genomation package:  

`ScoreMatrix(target = [path to bigwig file], windows = [regions of interest], type = "bigWig", strand.aware = [TRUE/FALSE])`   

* To take into account the strand of the TSS, we set `strand.aware` to TRUE.   
* Every row in the resulting ScoreMatrix object corresponds to a window of the [regions of interest].  
* Every column in the resulting ScoreMatrix object is a bp within that window.   

![ScoreMatrix visual](images/genomation_scorematrix.png){width=50%}\   
<br>
The window of the TSS intervals in `tss_chr21` is currently 1bp. But we want to plot the signal *around* the TSS.  
<br>
We can resize these 1bp intervals to the size that we are interested with the function:  
`resize(x = [GRanges object], width = [desired width], fix = ["start", "end" or "center"])`.   
As we want to have a window *around* the TSS we will set the `fix =` parameter to "center".    
<br>
In the example below we obtain the H3K4me3 signal in a +/-10kb window around the TSSs that have a H3K4me3 peak (see above). Hit "Run Code" to view the structure of the resulting ScoreMatrix object.   

```{r h3k4me3_scores, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q2a"}
# define the windows:  
window <- 20000

# resize the tss interval to this window.
tss_window <- resize(tss_chr21, width = window, fix = "center")

# filter for TSSs with H3K4me3 peak nearby: 
tss_window_with_h3k4me3 <- tss_window %>% filter(name %in% dist_h3k4me3_to_tss$feature.name)

# path to bigwig file (in this case stored in the folder "extdata" of the library "learnr.proto" which contains data specific to this tutorial)
bw_h3k4me3 <- system.file("extdata", "week3",  "C000S5H2_ERX547984_H3K4me3_bwa_GRCh38_20150528_chr21_TSS_20kb.bw", package = "learnr.proto")

# create H3K4me3 ScoreMatrix for these intervals.
# strand.aware =TRUE takes into account the strand of the TSS. 
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window_with_h3k4me3, type = 'bigWig', strand.aware =TRUE)  

# what structure is scores_h3k4me3? Hit "Run code" to view the result. 
str(scores_h3k4me3_tss)
```
<br>
The object `scores_h3k4me3_tss` is of formal class ScoreMatrix, which is related to a basic matrix but - as it says - "more formal". In other words, it has special functions to retrieve and set the data. We won't go into the details of these differences with basic matrices but focus on how we can use this result.  

### 3.3.3 Density plot of H3K4me3 signal around the TSS  
Using this ScoreMatrix we can plot the average H3K4me3 signal in these windows. To do so, we use the function:   
`plotMeta(mat = [score matrix object])`.  

* Run the code below to view the resulting plot.  
* We define the x-coordinates with the `xcoord = ` parameter to set the TSS at 0. If you remove them you will see that the x-axis is labeled from 0 to 20000.  

```{r example_densityplot, exercise =TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup = "h3k4me3_scores"}
# plot density plot
plotMeta(scores_h3k4me3_tss, xcoord = c(-10000, 10000))
```
Clearly, we could have focused our plot on the region +/- 5kb as the signal remains near 0 before -5kb and after 5kb.  

```{r mc_strandawareness}
question("Which command would you change and how, to make sure that the signal is limited to +/-5kb around the TSSs in the density plot?",
         answer("Change the xcoord parameter in 'plotMeta', set it to c(-5000, 5000)."),
         answer("Filter the ScoreMatrix 'scores_h3k4me3_tss' for columns c(-5000, 5000)."),
         answer("Change the width parameter in 'resize', set it to 10000.", correct = T, message =  "Let's make this plot!"),
         allow_retry = T,
         random_answer_order = T)
```


### Changing the window to +/- 5kb  
Repeat the calculations of the window, scores and plot from above but now make sure you plot a window +/- 5kb.  

```{r h3k4me3_scores, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_q2a"}
# define the windows:  
window <- 10000

# resize the tss interval to this window.
tss_window <- resize(tss_chr21, width = window, fix = "center")

# filter for TSSs with H3K4me3 peak nearby: 
tss_window_with_h3k4me3 <- tss_window %>% filter(name %in% dist_h3k4me3_to_tss$feature.name)

# path to bigwig file (in this case stored in the folder "extdata" of the library "learnr.proto" which contains data specific to this tutorial)
bw_h3k4me3 <- system.file("extdata", "week3",  "C000S5H2_ERX547984_H3K4me3_bwa_GRCh38_20150528_chr21_TSS_20_kb.bw", package = "learnr.proto")

# create H3K4me3 ScoreMatrix for these intervals.
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window_with_h3k4me3, type = 'bigWig', strand.aware =TRUE)  

# generate the density plot
plotMeta(scores_h3k4me3_tss, xcoord = c(-5000, 5000) )
```


```{r mc_strandawareness}
quiz(caption = "", 
     question("Is H3K4me3 signal equally strong before and after the TSS or is there a difference?",
              answer("H3K4me3 signal appears equal up- and downstream the TSS"),
              answer("H3K4me3 signal is lower downstream the TSS compared to upstream  "),
              answer("H3K4me3 signal is higher downstream the TSS", correct = T, message = "H3K4me3 signal is generally higher downstream the TSS."),
              allow_retry = T),
     question("What would the plot show, in case you would have set 'strand.aware =FALSEALSE' in the 'ScoreMatrix()' function? You can adjust the code and try it out.",
              answer("H3K4me3 signal appearing equal up- and downstream the TSS", correct = T, message = "As TSS are randomly distributed over strands, setting strand.aware to FALSE will lead to a plot where H3K4me3 signal appears equally strong before and after the TSS while in reality it is stronger downstream the TSS."),
              answer("H3K4me3 signal would appear lower downstream the TSS compared to upstream.", message = "Realize that randomly distributed over strands while the H3K4me3 signal around the TSS is related to the directionality."),
              answer("H3K4me3 signal would appear higher downstream the TSS", message = "Realize that randomly distributed over strands while the H3K4me3 signal around the TSS is related to the directionality."),
              allow_retry = T),
     question("What could explain the slight decrease in signal at pos. 0?", 
              answer("The nucleosome depleted region found at the TSS of transcribed genes.", correct = T),
              answer("The binding of specific TFs at the TSS."),
              answer("The TSS itself is marked by H3K4ac instaed of H3K4me3"),
              allow_retry = T)
)
```

### 3.3.4 Add H3K27me3 signal   
So far we have examined the signal of a 'narrowPeak' ChIP. Now, let's add the H3K27me3 signal to our plot.  

### Exercise 4  

> **Exercise 4**: Generate a density plot of the H3K37me3 signal +/- 10kb around the TSSs with H3K4me3 (code check).  

```{r h3k37me3_signal_tss, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.lines=9, exercise.setup="h3k4me3_scores"}
# 1. Path to bigwig file 
bw_h3k27me3 <- system.file("extdata", "week3",  "C000S5H2_ERX547983_H3K27me3_bwa_GRCh38_20150528_chr21_TSS_20_kb.bw", package = "learnr.proto")

# 2. Create H3K27me3 ScoreMatrix for these intervals.
scores_h3k27me3_tss <- ScoreMatrix(___)  

# 3. Generate the H3K27me3 density plot

```

```{r h3k37me3_signal_tss-hint-1}
# You can copy-paste the ScoreMatrix code from the exercise above and adjust the parameter 'targets' 
```

```{r h3k37me3_signal_tss-hint-2}
# Eg 
ScoreMatrix(target = bw_h3k27me3, windows = tss_window_with_h3k4me3, .....)  
```

```{r h3k37me3_signal_tss-hint3}
# Warning: the next hint holds the solution!
```

```{r h3k37me3_signal_tss-solution}
# 1. path to bigwig file (in this case stored in the folder "extdata" of the library "learnr.proto" which contains data specific to this tutorial)
bw_h3k27me3 <- system.file("extdata", "week3",  "C000S5H2_ERX547983_H3K27me3_bwa_GRCh38_20150528_chr21_TSS_20_kb.bw", package = "learnr.proto")

# 2. create H3K27me3 ScoreMatrix for the TSS windows with H3K4me3
scores_h3k27me3_tss <- ScoreMatrix(target = bw_h3k27me3, windows = tss_window_with_h3k4me3, type = 'bigWig', strand.aware =TRUE)  

# 3. generate the H3K27me3 density plot
plotMeta(scores_h3k27me3_tss, xcoord = c(-5000, 5000))
```

```{r h3k37me3_signal_tss-code-check}
grade_code()
```

Observe the difference in y-axis values between the density plot of H3K4me3 and H3K27me3. This reflects the different nature of these marks with H3K4me3 having a much larger range (as you might have observed in the genome browser). Additionally, not all H3K4me3 positive TSSs have H3K27me3 and the signal of the latter gets diluted (however, in this case, this is negligable. If you plot TSS with only H3K27me3 signal you will see that the maximum signal does not exceed 4.5).   

### Exercise 5  
Lastly, we can combine plots of two marks with by  

1. generating a "ScoreMatrixList" object. 
2. provide plotMeta with this "ScoreMatrixList".  

See the following example:  

```{r prepare_overlay_density, echo=FALSE}
dist_h3k4me3_to_tss <- distance2NearestFeature(monocytes_h3k4me3, tss_chr21)
window <- 10000
tss_window <- resize(tss_chr21, width = window, fix = "center")
tss_window_with_h3k4me3 <- tss_window %>% filter(name %in% dist_h3k4me3_to_tss$feature.name)
# scores for h3k27me3
bw_h3k4me3 <- system.file("extdata", "week3",  "C000S5H2_ERX547984_H3K4me3_bwa_GRCh38_20150528_chr21_TSS_20kb.bw", package = "learnr.proto")
scores_h3k4me3_tss <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window_with_h3k4me3, type = 'bigWig', strand.aware =TRUE)  
# scores for h3k27me3
bw_h3k27me3 <- system.file("extdata", "week3",  "C000S5H2_ERX547983_H3K27me3_bwa_GRCh38_20150528_chr21_TSS_20_kb.bw", package = "learnr.proto")
scores_h3k27me3_tss <- ScoreMatrix(target = bw_h3k27me3, windows = tss_window_with_h3k4me3, type = 'bigWig', strand.aware =TRUE)  
```

```{r overlay_density, exercise=TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup="prepare_overlay_density"}
# generate ScoreMartixList from two ScoreMatrix objects:
scores_h3k4me3_h3k27me3_tss <- new("ScoreMatrixList", list(k4me3=scores_h3k4me3_tss, k27me3=scores_h3k27me3_tss))

# generate density plot
plotMeta(scores_h3k4me3_h3k27me3_tss, xcoord = c(-5000, 5000), overlay =TRUE, profile.names = c("H3K4me3", "H3K27me3"))
```
## 3.4 Signal vs gene expression  
In fg2 we already observed a difference in expression between genes with and without overlap of a H3K4me3 peak and their promoter. What if we, besides the binary measure of peak presence/absence, took into account the actual signal intensity, would that improve our explanation of gene expression differences?  
<br>
In this section you will plot the relationship between H3K4me3 signal at the TSS and the extend of gene expression (as FPKM).  

### 3.4.1 Summarize signal scores   
First, we will calculate the average H3K4me3 signal in 10kb around *all TSSs*. We can do this quickly with a modified version of the 'ScoreMatrix' function we used above: `ScoreMatrixBin()`.  
<br>
As the name suggests, this function does not calculate the signal for each bp in the given windows, but for each bin. If we set the `bin.num` parameter to `1`, it will output the average signal per window. Note that this function is also useful when working with windows of varying size like complete genes, in those cases we set `bin.num` to 50 or 100.    

> **Exercise 6**: Calculate the average H3K4me3 signal in a window of +/- 5kb around the TSS. Do this for *all* TSSs, irrespective of their overlap of distance to a H3K4me3 peak.   

```{r q6_prepare}


```

```{r}
window <- 5000
tss_window <- resize(tss_chr21, width = window, fix = "center")
average_score_h3k4me3_tss <- ScoreMatrixBin(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', bin.num = 1, strand.aware =TRUE)  # gives the average score over the complete window. And not the sum of 1bp bin windows. 
scores_as_matrix <- as(average_score_h3k4me3_tss, "matrix")
scores_as_df <- as.data.frame(scores_as_matrix)
scores_as_df$gene_id <- tss_window$gene_id
h3K4me3_and_rnaquant <- merge(scores_as_df, quantification_chr21, by.x = "gene_id", by.y = "entrezgene_id")
h3K4me3_and_rnaquant %>% 
  mutate(expression_group = ntile(FPKM, 4)) %>% 
  ggplot(.)+ 
  geom_boxplot(mapping=aes(x = as.factor(expression_group), y = V1))
h3K4me3_and_rnaquant %>% 
  mutate(expression_group = ntile(FPKM, 4)) %>% 
  ggplot(.)+ 
  geom_point(mapping=aes(col = as.factor(expression_group), x = log2(FPKM+1) ,y = V1)) 

window <- 10000
tss_window <- resize(tss_chr21, width = window, fix = "center")
average_score_h3k4me3_tss <- ScoreMatrixBin(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', bin.num = 1, strand.aware =TRUE)  # gives the average score over the complete window. And not the sum of 1bp bin windows. 
scores_as_matrix <- as(average_score_h3k4me3_tss, "matrix")
scores_as_df <- as.data.frame(scores_as_matrix)
scores_as_df$gene_id <- tss_window$gene_id
h3K4me3_and_rnaquant <- merge(scores_as_df, quantification_chr21, by.x = "gene_id", by.y = "entrezgene_id")
h3K4me3_and_rnaquant %>% 
  mutate(expression_group = ntile(FPKM, 4)) %>% 
  ggplot(.)+ 
  geom_boxplot(mapping=aes(x = as.factor(expression_group), y = V1))
h3K4me3_and_rnaquant %>% 
  mutate(expression_group = ntile(FPKM, 4)) %>% 
  ggplot(.)+ 
  geom_point(mapping=aes(col = as.factor(expression_group), x = log2(FPKM+1) ,y = V1))


window <- 20000
tss_window <- resize(tss_chr21, width = window, fix = "center")
average_score_h3k4me3_tss <- ScoreMatrixBin(target = bw_h3k4me3, windows = tss_window, type = 'bigWig', bin.num = 1, strand.aware =TRUE)  # gives the average score over the complete window. And not the sum of 1bp bin windows. 
scores_as_matrix <- as(average_score_h3k4me3_tss, "matrix")
scores_as_df <- as.data.frame(scores_as_matrix)
scores_as_df$gene_id <- tss_window$gene_id
h3K4me3_and_rnaquant <- merge(scores_as_df, quantification_chr21, by.x = "gene_id", by.y = "entrezgene_id")
h3K4me3_and_rnaquant %>% 
  mutate(expression_group = ntile(FPKM, 4)) %>% 
  ggplot(.)+ 
  geom_boxplot(mapping=aes(x = as.factor(expression_group), y = V1)) 
h3K4me3_and_rnaquant %>% 
  mutate(expression_group = ntile(FPKM, 4)) %>% 
  ggplot(.)+ 
  geom_point(mapping=aes(col = as.factor(expression_group), x = log2(FPKM+1) ,y = V1))


# h3K4me3_and_rnaquant <- merge(scores_as_df, quantification_chr21, by.x = "gene_id", by.y = "entrezgene_id")
# h3K4me3_and_rnaquant %>% 
#   mutate(expression_group = ntile(FPKM, 4)) %>% 
#   ggplot(.)+ 
#   geom_boxplot(mapping=aes(x = as.factor(expression_group), y = V1))


# scores_h3k4me3_tss_10kb <- ScoreMatrix(target = bw_h3k4me3, windows = tss_window, type = 'bigWig',strand.aware =TRUE) 
# scores_as_df_10kb <- as.data.frame(tss_window$gene_id)
# colnames(scores_as_df_10kb) <- "gene_id"
# scores_as_df_10kb$mean_h3k4me3 <- apply(as(scores_h3k4me3_tss_10kb, "matrix"), 1, mean)
# scores_as_df_10kb$sum_h3k4me3 <- apply(as(scores_h3k4me3_tss_10kb, "matrix"), 1, sum)
# scores10kb_and_quant <- merge(scores_as_df_10kb, quantification_chr21, by.x = "gene_id", by.y = "entrezgene_id")
# cor(log10(scores10kb_and_quant$FPKM+1), scores10kb_and_quant$sum_h3k4me3)
# cor(log10(scores10kb_and_quant$FPKM+1), scores10kb_and_quant$mean_h3k4me3)
# 
# head(scores_as_df_10kb)
```

### 3.4.1 H3K4me3 signal vs gene expression  
Plot the relationship between ChIP-seq signal at the TSS and gene expression per gene expression quantile.

### 3.4.2 Scatter visualization of this relationship  
For each TSS we have a ChIP-seq signal and gene expression signal. Plot in scatter plot.  

### 3.4.3 What about H3K27me3 signal vs. gene experession?  



## 3.4 Heatmaps  

<!-- ```{r example_densityplot, exercise =TRUE, exercise.eval=FALSE, error=TRUE, exercise.setup = "example_scores"} -->
<!-- # plot density plot -->
<!-- plotMeta(scores_h3k4me3_tss, xcoord = c(-5000, 5000)) -->
<!-- plotMeta(scores_h3k4me3_tss_all, xcoord = c(-5000, 5000)) -->

<!-- # plot heatmap -->
<!-- heatMatrix(scores_h3k4me3_tss, xcoord = c(-5000, 5000), order = T) -->
<!-- heatMatrix(scores_h3k4me3_tss_all, xcoord = c(-5000, 5000), order = T) -->

<!-- # k-means clustering -->
<!-- cl1 <- function(x) kmeans(x, centers=3)$cluster -->
<!-- set.seed(1000) -->
<!-- heatMatrix(mat=scores_h3k4me3_tss_all,legend.name="tpm",winsorize=c(0,99),xlab="region around TSS", -->
<!--          xcoords=c(-5000:4999),clustfun=cl1, -->
<!--          cex.legend=0.8,main="H3K4me3 signal on promoters",cex.lab=1, -->
<!--          cex.axis=0.9,grid=FALSE, -->
<!--          user.order=c(1,3,2)) -->

<!-- # hierarchical clustering -->
<!-- cl2 <- function(x) cutree(hclust(dist(x), method="complete"), k=3) -->
<!-- set.seed(1000) -->
<!-- heatMatrix(mat=scores_h3k4me3_tss_all,legend.name="tpm",winsorize=c(0,99),xlab="region around TSS", -->
<!--          xcoords=c(-5000:4999),clustfun=cl2, -->
<!--          cex.legend=0.8,main="H3K4me3 signal on promoters",cex.lab=1, -->
<!--          cex.axis=0.9,grid=FALSE) -->
<!-- ``` -->
### 3.4.1 Heatmap of 1 mark  
Summarize H3K4me3 ChIP-seq signal at all TSSs in a heatmap.  

### 3.4.2 Ordering a heatmap  
By gene expression of corresponding gene  

### 3.4.3 Clustering a heatmap  
By k-means or hierarchical clustering. 
Perhaps add background info section on clustering (?)  

### 3.4.4 Heatmap of all available histone marks  
Heatmap of all marks at the TSSs.   

### 3.4.5
Heatmap of all marks at DNaseI summits.   

## 3.5 ChromHMM  
Back-analyze chromHmm output, in other words, heatmap summary of signal intensities of the different marks in chromHMM defined regions. Regions are labelled 1-12, can you, using the sig

Chromatin states - re-occurring, co-localization of histone marks and factors - mapping of epigenomic marks, such as histone modifications, histone variants, regions of open chromatin, and related marks, has emerged as a powerful means to annotate genomes, to identify putative regulatory elements, and to study their changing activity across different cell types and in human disease1,2,3,4. Individual marks can be studied in isolation, either through aggregation of their genome-wide signal tracks relative to a set of predetermined annotations5, such as transcription start sites or exon boundaries, or by discovery of narrow peaks or broader domains in which the mark is present in greater frequency than that of the surrounding regions6. However, additional information can be gained by studying combinations of multiple marks in their spatial context. Such patterns, termed 'chromatin states', often capture known classes of genomic elements, such as promoters, enhancers, and transcribed, repressed, and repetitive regions7, and can also capture novel classes or subclasses of elements. (https://www.nature.com/articles/nprot.2017.124)

State1.- Repressed Polycomb High signal H3K27me3 -A 
State2.- Repressed Polycomb Low signal H3K27me3 - A
state3.- Low signal
State4.- Heterochromatin High Signal H3K9me3 - B
State5.- Transcription High signal H3K36me3 - C 
State6.- Transcription Low signal H3K36me3 -C
State7.- Genic Enhancer High Signal H3K4me1 & H3K36me3
State8.- Enhancer High Signal H3K4me1
State9.- Active Enhancer High Signal H3K4me1 & H3K27Ac - D
State10.- Distal Active Promoter (2Kb) High Signal H3K4me3 & H3K27Ac & H3K4me1 - D
State11.- Active TSS High Signal H3K4me3 & H3K4me1 - E 
state12.- Active TSS High Signal H3K4me3 & H3K27Ac - E

### Exercise chromhmm    
```{r chromhmm, eval =FALSE}
#library(pheatmap)
library(RColorBrewer)
chromhmm_file <- system.file("extdata", "week3",  "C000S5H1_12_12_Blueprint_release_201608_dense_chr21.bed", package = "learnr.proto")
chromhmm <- rtracklayer::import(chromhmm_file)
# 12 states - which is what?  
table(chromhmm$name)  
chromhmm_list <- split(chromhmm, chromhmm$name,drop=TRUE)

mono_list <- GRangesList(monocytes_list, compress =FALSE)

chrommhmm_anno_list <- annotateWithFeatures(mono_list,chromhmm_list)
heatTargetAnnotation(chrommhmm_anno_list)+
  coord_flip()+
  scale_fill_gradient(low = "white", high = "blue")
  
mat=heatTargetAnnotation(chrommhmm_anno_list,plot=FALSE)



#pheatmap(mat = mat, 
#         color = c("white", brewer.pal("Reds", n =9)),
#         cluster_cols =FALSE)

      
#BiocManager::install("pheatmap")

```